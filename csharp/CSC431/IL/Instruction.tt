<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".generated.cs" #>
<#@ Import Namespace="System.Collections.Generic" #>
using CSC431.CFG;
using System;
using System.Collections.Generic;

namespace CSC431.IL
{

<#
foreach (var instr in InstrInfo.GetAll())
{
    var className = instr.ClassName.Substring(1).Insert(0, char.ToUpper(instr.ClassName[0]).ToString()) + "Instruction";
#>
public partial class <#=className #> : MilocInstruction
{
	public <#=className #>
	(
<#
instr.ForEachOperand((c, count, isLast) =>
{
    if (c.IsConstant)
        return;
    Write("{0} {1}{2}", c.Type, c.LowerPrefix, count);
    if (!isLast)
        Write(",");
});
#>
	) : base ("<#=instr.Name #>")
	{
<#
instr.ForEachOperand((c, count, isLast) =>
{
    if (c.IsConstant)
        return;
    Write("this.{0}{1} = {2}{1};", c.UpperPrefix, count, c.LowerPrefix);
});
if (instr.IsSetCC)
{
#>
		this.CcSet = true;
<#
}
#>
	}

<#
instr.ForEachOperand((c, count, isLast) =>
{
    if (c.IsConstant)
        return;
    WriteLine("public {1} {2}{0}{{ get; private set; }}", count, c.Type, c.UpperPrefix);
});
#>

public override Register[] SourceRegs
{
	get
	{
		return new Register[] {
<#
instr.ForEachOperand((c, count, isLast) =>
{
    if (!c.IsSource)
        return;
    Write("{1}{0}", count, c.UpperPrefix);
    if (!isLast)
        Write(", ");
});
#>
		};
	}
}

public override Register[] DestRegs
{
	get
	{
		return new Register[] {
<#
instr.ForEachOperand((c, count, isLast) =>
{
    if (!c.IsTarget)
        return;
    Write("{1}{0}", count, c.UpperPrefix);
    if (!isLast)
        Write(", ");
});
#>
		};
	}
}

public override string ToString()
{
<#
int placeHolderCount = 1;
string formatStr = "{0}";
instr.ForEachOperand((c, count, isLast) =>
{
    if (c.IsConstant)
        formatStr += " " + c.ConstantValue;
    else
        formatStr += " " + c.MilocPrefix + "{" + placeHolderCount + "}" + c.MilocPostfix;
    if (!isLast)
        formatStr += ",";
    placeHolderCount++;
});
Write("return string.Format(\"{0}\", Name", formatStr);
instr.ForEachOperand((c, count, isLast) =>
{
    string field = c.UpperPrefix + count;
    Write(", ");
    if (c.IsConstant)
    {
        Write("null");
        return;
    }
    if (string.IsNullOrEmpty(c.SpecialConversion))
        Write(field);
    else
        Write(c.SpecialConversion, field);
});
#>
);
}
}



<#
}
#>
public interface IMilocTranslator<T> where T : Instruction
{
	IEnumerable<T> FunctionStart(FunctionBlock<MilocInstruction> block);
<#
    foreach (var instr in InstrInfo.GetAll())
    {
        var name = instr.ClassName.Substring(1).Insert(0, char.ToUpper(instr.ClassName[0]).ToString());
        var className = name + "Instruction";
#>
	IEnumerable<T> <#= name #>(<#= className #> s, InstructionStream<MilocInstruction> stream);
<#
    }
#>
}

public class MilocIdentityTranslator : IMilocTranslator<MilocInstruction>
{
	public IEnumerable<MilocInstruction> FunctionStart(FunctionBlock<MilocInstruction> block)
	{
		yield break;
	}
<#
    foreach (var instr in InstrInfo.GetAll())
    {
        var name = instr.ClassName.Substring(1).Insert(0, char.ToUpper(instr.ClassName[0]).ToString());
        var className = name + "Instruction";
#>
	public IEnumerable<MilocInstruction> <#= name #>(<#= className #> s, InstructionStream<MilocInstruction> stream) { yield return s; }
<#
    }
#>
}

public class MilocConverter<T> : IInstructionConverter<MilocInstruction, T>
	where T : Instruction
{
	private IMilocTranslator<T> translator;
	public MilocConverter(IMilocTranslator<T> translator)
	{
		this.translator = translator;
	}

	public IEnumerable<T> FunctionStart(FunctionBlock<MilocInstruction> block)
	{
		return translator.FunctionStart(block);
	}

	public IEnumerable<T> Convert(InstructionStream<MilocInstruction> s)
	{
		while (s.More)
		{
			var cur = s.Consume();
<#
    foreach (var instr in InstrInfo.GetAll())
    {
        var name = instr.ClassName.Substring(1).Insert(0, char.ToUpper(instr.ClassName[0]).ToString());
        var className = name + "Instruction";
#>
			if (cur is <#= className #>)
			{
				var conv = cur as <#= className #>;
				foreach (var newInstr in translator.<#= name #>(conv, s))
					yield return newInstr;
				continue;
			}
<#
    }
#>
			throw new NotSupportedException();
		}
	}
}

}
<#+
[Flags]
private enum InstrFlags : int
{
    None = 0,
    SetCC = 1,
    UseCC = 2
}
private class OperandType
{
    private static Dictionary<char, OperandType> sTypes = new Dictionary<char, OperandType>();
    static OperandType()
    {
        sTypes.Add('r', new OperandType() { LowerPrefix = "regSource", UpperPrefix = "RegSource", Type = "Register", IsSource = true });
        sTypes.Add('R', new OperandType() { LowerPrefix = "regDest", UpperPrefix = "RegDest", Type = "Register", IsTarget = true });
        sTypes.Add('l', new OperandType() { LowerPrefix = "label", UpperPrefix = "Label", MilocPrefix = "L", Type = "Label" });
        sTypes.Add('i', new OperandType() { LowerPrefix = "immed", UpperPrefix = "Immed", Type = "int" });
        sTypes.Add('s', new OperandType() { LowerPrefix = "str", UpperPrefix = "Str", Type = "string" });
        sTypes.Add('a', new OperandType() { LowerPrefix = "arr", UpperPrefix = "Arr", MilocPrefix = "[", MilocPostfix = "]", Type = "string[]", SpecialConversion = "string.Join(\", \", {0})" });
        sTypes.Add('k', new OperandType() { ConstantValue = "rarp" });
    }

    public string LowerPrefix { get; private set; }
    public string UpperPrefix { get; private set; }
    public string MilocPrefix { get; private set; }
    public string MilocPostfix { get; private set; }
    public string Type { get; private set; }
    public string SpecialConversion { get; private set; }
    public bool IsSource { get; private set; }
    public bool IsTarget { get; private set; }

    public string ConstantValue { get; private set; }
    public bool IsConstant
    {
        get
        {
            return ConstantValue != null;
        }
    }

    public static OperandType Get(char letter)
    {
        return sTypes[letter];
    }
}
private class InstrInfo
{
    public InstrInfo(String type, string name)
        : this(type, name, name)
    {
    }

    public InstrInfo(String type, string name, string className)
    {
        this.Type = type;
        this.Name = name;
        this.ClassName = className;
    }

    public InstrInfo(String type, string name, InstrFlags flags)
        : this(type, name)
    {
        this.Flags = flags;
    }

    public InstrFlags Flags { get; private set; }
    public string Type { get; private set; }
    public string Name { get; private set; }
    public string ClassName { get; private set; }

    public bool IsSetCC
    {
        get
        {
            return ((Flags & InstrFlags.SetCC) != 0);
        }
    }

    public void ForEachOperand(Action<OperandType, int, bool> f)
    {
        var count = new Dictionary<char, int>();
        for (int i = 0; i < Type.Length; i++)
        {
            char c = Type[i];
            if (!count.ContainsKey(c))
                count[c] = 0;
            f(OperandType.Get(c), count[c]++, i == Type.Length - 1);
        }
    }

    public static InstrInfo[] GetAll()
    {
        return new[]
            {
                new InstrInfo("rrR", "add"),
                new InstrInfo("riR", "addi"),
                new InstrInfo("rrR", "div"),
                new InstrInfo("rrR", "mult"),
                new InstrInfo("rrR", "sub"),
                new InstrInfo("riR", "rsubi"),
                new InstrInfo("rrR", "and"),
                new InstrInfo("rrR", "or"),
                new InstrInfo("riR", "xori"),
                new InstrInfo("iR", "loadi"),
                new InstrInfo("r", "print"),
                new InstrInfo("r", "println"),
                new InstrInfo("r", "read"),
                new InstrInfo("rr", "comp", InstrFlags.SetCC),
                new InstrInfo("rR", "mov"),
                new InstrInfo("iR", "moveq", InstrFlags.UseCC),
                new InstrInfo("iR", "movge", InstrFlags.UseCC),
                new InstrInfo("iR", "movgt", InstrFlags.UseCC),
                new InstrInfo("iR", "movle", InstrFlags.UseCC),
                new InstrInfo("iR", "movlt", InstrFlags.UseCC),
                new InstrInfo("iR", "movne", InstrFlags.UseCC),
                new InstrInfo("l", "jumpi"),
                new InstrInfo("ll", "cbreq"),
                new InstrInfo("siR", "loadinargument"),
                new InstrInfo("s", "call"),
                new InstrInfo("", "ret"),
                new InstrInfo("r", "storeret"),
                new InstrInfo("ri", "storeoutargument"),
                new InstrInfo("R", "loadret"),
                new InstrInfo("rrs", "storeai", "storeaiField"),
                new InstrInfo("rks", "storeai", "storeaiVar"),
                new InstrInfo("rsR", "loadai", "loadaiField"),
                new InstrInfo("ksR", "loadai", "loadaiVar"),
                new InstrInfo("sR", "loadglobal"),
                new InstrInfo("rs", "storeglobal"),
                new InstrInfo("sR", "computeglobaladdress"),
                new InstrInfo("saR", "new"),
                new InstrInfo("r", "del"),
            };
    }
}
#>