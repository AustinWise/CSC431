// $ANTLR 3.3 Nov 30, 2010 12:50:56 IlGenWalker.g 2011-02-17 00:08:10

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162


   /* <auto-generated> */
   using CSC431.CFG;


using System;
using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;using Stack = System.Collections.Generic.Stack<object>;
using List = System.Collections.IList;
using ArrayList = System.Collections.Generic.List<object>;

namespace CSC431.IL
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3 Nov 30, 2010 12:50:56")]
[System.CLSCompliant(false)]
public partial class IlGenWalker : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "STRUCT", "INT", "BOOL", "FUN", "VOID", "PRINT", "ENDL", "READ", "IF", "ELSE", "WHILE", "DELETE", "RETURN", "TRUE", "FALSE", "NEW", "NULL", "PROGRAM", "TYPES", "TYPE", "DECLS", "FUNCS", "DECL", "DECLLIST", "PARAMS", "RETTYPE", "BLOCK", "STMTS", "INVOKE", "ARGS", "NEG", "LBRACE", "RBRACE", "SEMI", "COMMA", "LPAREN", "RPAREN", "ASSIGN", "DOT", "AND", "OR", "EQ", "LT", "GT", "NE", "LE", "GE", "PLUS", "MINUS", "TIMES", "DIVIDE", "NOT", "ID", "INTEGER", "WS", "COMMENT"
	};
	public const int EOF=-1;
	public const int STRUCT=4;
	public const int INT=5;
	public const int BOOL=6;
	public const int FUN=7;
	public const int VOID=8;
	public const int PRINT=9;
	public const int ENDL=10;
	public const int READ=11;
	public const int IF=12;
	public const int ELSE=13;
	public const int WHILE=14;
	public const int DELETE=15;
	public const int RETURN=16;
	public const int TRUE=17;
	public const int FALSE=18;
	public const int NEW=19;
	public const int NULL=20;
	public const int PROGRAM=21;
	public const int TYPES=22;
	public const int TYPE=23;
	public const int DECLS=24;
	public const int FUNCS=25;
	public const int DECL=26;
	public const int DECLLIST=27;
	public const int PARAMS=28;
	public const int RETTYPE=29;
	public const int BLOCK=30;
	public const int STMTS=31;
	public const int INVOKE=32;
	public const int ARGS=33;
	public const int NEG=34;
	public const int LBRACE=35;
	public const int RBRACE=36;
	public const int SEMI=37;
	public const int COMMA=38;
	public const int LPAREN=39;
	public const int RPAREN=40;
	public const int ASSIGN=41;
	public const int DOT=42;
	public const int AND=43;
	public const int OR=44;
	public const int EQ=45;
	public const int LT=46;
	public const int GT=47;
	public const int NE=48;
	public const int LE=49;
	public const int GE=50;
	public const int PLUS=51;
	public const int MINUS=52;
	public const int TIMES=53;
	public const int DIVIDE=54;
	public const int NOT=55;
	public const int ID=56;
	public const int INTEGER=57;
	public const int WS=58;
	public const int COMMENT=59;

	// delegates
	// delegators

	#if ANTLR_DEBUG
		private static readonly bool[] decisionCanBacktrack =
			new bool[]
			{
				false, // invalid decision
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false
			};
	#else
		private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public IlGenWalker( ITreeNodeStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public IlGenWalker(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
		

	public override string[] TokenNames { get { return IlGenWalker.tokenNames; } }
	public override string GrammarFileName { get { return "IlGenWalker.g"; } }



 	protected virtual void OnCreated() {}
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}


    protected virtual void Enter_program() {}
    protected virtual void Leave_program() {}

    // $ANTLR start "program"
    // IlGenWalker.g:18:1: program returns [ProgramBlock<MilocInstruction> prog] : ^( PROGRAM ( types declarations[false,globalStructMap] funs= functions ) ) ;
    [GrammarRule("program")]
    private ProgramBlock<MilocInstruction> program()
    {

        ProgramBlock<MilocInstruction> prog = default(ProgramBlock<MilocInstruction>);

        List<FunctionBlock<MilocInstruction>> funs = default(List<FunctionBlock<MilocInstruction>>);

    	try { DebugEnterRule(GrammarFileName, "program");
    	DebugLocation(18, 1);
    	try
    	{
    		// IlGenWalker.g:19:2: ( ^( PROGRAM ( types declarations[false,globalStructMap] funs= functions ) ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:19:4: ^( PROGRAM ( types declarations[false,globalStructMap] funs= functions ) )
    		{
    		DebugLocation(19, 4);
    		DebugLocation(19, 6);
    		Match(input,PROGRAM,Follow._PROGRAM_in_program59); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(19, 14);
    		// IlGenWalker.g:19:14: ( types declarations[false,globalStructMap] funs= functions )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:19:15: types declarations[false,globalStructMap] funs= functions
    		{
    		DebugLocation(19, 15);
    		PushFollow(Follow._types_in_program62);
    		types();
    		PopFollow();

    		DebugLocation(19, 21);
    		PushFollow(Follow._declarations_in_program64);
    		declarations(false, globalStructMap);
    		PopFollow();

    		DebugLocation(19, 61);
    		PushFollow(Follow._functions_in_program69);
    		funs=functions();
    		PopFollow();


    		}


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(19, 74);
    		prog = new ProgramBlock<MilocInstruction>(funs);

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(20, 1);
    	} finally { DebugExitRule(GrammarFileName, "program"); }
    	return prog;

    }
    // $ANTLR end "program"


    protected virtual void Enter_types() {}
    protected virtual void Leave_types() {}

    // $ANTLR start "types"
    // IlGenWalker.g:22:1: types : ( ^( TYPES types_sub ) | TYPES );
    [GrammarRule("types")]
    private void types()
    {

    	try { DebugEnterRule(GrammarFileName, "types");
    	DebugLocation(22, 3);
    	try
    	{
    		// IlGenWalker.g:23:4: ( ^( TYPES types_sub ) | TYPES )
    		int alt1=2;
    		try { DebugEnterDecision(1, decisionCanBacktrack[1]);
    		int LA1_0 = input.LA(1);

    		if ((LA1_0==TYPES))
    		{
    			int LA1_1 = input.LA(2);

    			if ((LA1_1==DOWN))
    			{
    				alt1=1;
    			}
    			else if (((LA1_1>=DECLS && LA1_1<=FUNCS)))
    			{
    				alt1=2;
    			}
    			else
    			{
    				NoViableAltException nvae = new NoViableAltException("", 1, 1, input);

    				DebugRecognitionException(nvae);
    				throw nvae;
    			}
    		}
    		else
    		{
    			NoViableAltException nvae = new NoViableAltException("", 1, 0, input);

    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    		} finally { DebugExitDecision(1); }
    		switch (alt1)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:23:7: ^( TYPES types_sub )
    			{
    			DebugLocation(23, 7);
    			DebugLocation(23, 9);
    			Match(input,TYPES,Follow._TYPES_in_types88); 

    			if (input.LA(1) == TokenTypes.Down)
    			{
    				Match(input, TokenTypes.Down, null); 
    				DebugLocation(23, 15);
    				PushFollow(Follow._types_sub_in_types90);
    				types_sub();
    				PopFollow();


    				Match(input, TokenTypes.Up, null); 
    			}

    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// IlGenWalker.g:24:7: TYPES
    			{
    			DebugLocation(24, 7);
    			Match(input,TYPES,Follow._TYPES_in_types99); 

    			}
    			break;

    		}
    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(25, 3);
    	} finally { DebugExitRule(GrammarFileName, "types"); }
    	return;

    }
    // $ANTLR end "types"


    protected virtual void Enter_type_declaration() {}
    protected virtual void Leave_type_declaration() {}

    // $ANTLR start "type_declaration"
    // IlGenWalker.g:27:1: type_declaration : ^( STRUCT (id= ID ) nested_decl[members] ) ;
    [GrammarRule("type_declaration")]
    private void type_declaration()
    {

        CommonTree id=null;

        List<StructMember> members = new List<StructMember>();
    	try { DebugEnterRule(GrammarFileName, "type_declaration");
    	DebugLocation(27, 3);
    	try
    	{
    		// IlGenWalker.g:29:4: ( ^( STRUCT (id= ID ) nested_decl[members] ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:29:7: ^( STRUCT (id= ID ) nested_decl[members] )
    		{
    		DebugLocation(29, 7);
    		DebugLocation(29, 9);
    		Match(input,STRUCT,Follow._STRUCT_in_type_declaration121); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(29, 16);
    		// IlGenWalker.g:29:16: (id= ID )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:29:17: id= ID
    		{
    		DebugLocation(29, 19);
    		id=(CommonTree)Match(input,ID,Follow._ID_in_type_declaration126); 

    		}

    		DebugLocation(30, 10);
    		PushFollow(Follow._nested_decl_in_type_declaration138);
    		nested_decl(members);
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(30, 32);
    		 structMap[(id!=null?id.Text:null)] = members; 

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(31, 3);
    	} finally { DebugExitRule(GrammarFileName, "type_declaration"); }
    	return;

    }
    // $ANTLR end "type_declaration"


    protected virtual void Enter_nested_decl() {}
    protected virtual void Leave_nested_decl() {}

    // $ANTLR start "nested_decl"
    // IlGenWalker.g:33:1: nested_decl[List<StructMember> members] : ( field_decl[$members] )+ ;
    [GrammarRule("nested_decl")]
    private void nested_decl(List<StructMember> members)
    {

    	try { DebugEnterRule(GrammarFileName, "nested_decl");
    	DebugLocation(33, 3);
    	try
    	{
    		// IlGenWalker.g:34:4: ( ( field_decl[$members] )+ )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:34:7: ( field_decl[$members] )+
    		{
    		DebugLocation(34, 7);
    		// IlGenWalker.g:34:7: ( field_decl[$members] )+
    		int cnt2=0;
    		try { DebugEnterSubRule(2);
    		while (true)
    		{
    			int alt2=2;
    			try { DebugEnterDecision(2, decisionCanBacktrack[2]);
    			int LA2_0 = input.LA(1);

    			if ((LA2_0==DECL))
    			{
    				alt2=1;
    			}


    			} finally { DebugExitDecision(2); }
    			switch (alt2)
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// IlGenWalker.g:34:8: field_decl[$members]
    				{
    				DebugLocation(34, 8);
    				PushFollow(Follow._field_decl_in_nested_decl160);
    				field_decl(members);
    				PopFollow();


    				}
    				break;

    			default:
    				if (cnt2 >= 1)
    					goto loop2;

    				EarlyExitException eee2 = new EarlyExitException( 2, input );
    				DebugRecognitionException(eee2);
    				throw eee2;
    			}
    			cnt2++;
    		}
    		loop2:
    			;

    		} finally { DebugExitSubRule(2); }


    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(35, 3);
    	} finally { DebugExitRule(GrammarFileName, "nested_decl"); }
    	return;

    }
    // $ANTLR end "nested_decl"


    protected virtual void Enter_types_sub() {}
    protected virtual void Leave_types_sub() {}

    // $ANTLR start "types_sub"
    // IlGenWalker.g:37:1: types_sub : ( ( type_declaration types_sub ) | );
    [GrammarRule("types_sub")]
    private void types_sub()
    {

    	try { DebugEnterRule(GrammarFileName, "types_sub");
    	DebugLocation(37, 3);
    	try
    	{
    		// IlGenWalker.g:38:4: ( ( type_declaration types_sub ) | )
    		int alt3=2;
    		try { DebugEnterDecision(3, decisionCanBacktrack[3]);
    		int LA3_0 = input.LA(1);

    		if ((LA3_0==STRUCT))
    		{
    			alt3=1;
    		}
    		else if ((LA3_0==UP))
    		{
    			alt3=2;
    		}
    		else
    		{
    			NoViableAltException nvae = new NoViableAltException("", 3, 0, input);

    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    		} finally { DebugExitDecision(3); }
    		switch (alt3)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:38:7: ( type_declaration types_sub )
    			{
    			DebugLocation(38, 7);
    			// IlGenWalker.g:38:7: ( type_declaration types_sub )
    			DebugEnterAlt(1);
    			// IlGenWalker.g:38:8: type_declaration types_sub
    			{
    			DebugLocation(38, 8);
    			PushFollow(Follow._type_declaration_in_types_sub180);
    			type_declaration();
    			PopFollow();

    			DebugLocation(38, 25);
    			PushFollow(Follow._types_sub_in_types_sub182);
    			types_sub();
    			PopFollow();


    			}


    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// IlGenWalker.g:40:4: 
    			{
    			}
    			break;

    		}
    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(40, 3);
    	} finally { DebugExitRule(GrammarFileName, "types_sub"); }
    	return;

    }
    // $ANTLR end "types_sub"


    protected virtual void Enter_field_decl() {}
    protected virtual void Leave_field_decl() {}

    // $ANTLR start "field_decl"
    // IlGenWalker.g:42:1: field_decl[List<StructMember> members] : ^( DECL ^( TYPE t= type ) id= ID ) ;
    [GrammarRule("field_decl")]
    private void field_decl(List<StructMember> members)
    {

        CommonTree id=null;
        String t = default(String);

    	try { DebugEnterRule(GrammarFileName, "field_decl");
    	DebugLocation(42, 3);
    	try
    	{
    		// IlGenWalker.g:43:4: ( ^( DECL ^( TYPE t= type ) id= ID ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:43:7: ^( DECL ^( TYPE t= type ) id= ID )
    		{
    		DebugLocation(43, 7);
    		DebugLocation(43, 9);
    		Match(input,DECL,Follow._DECL_in_field_decl207); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(43, 14);
    		DebugLocation(43, 16);
    		Match(input,TYPE,Follow._TYPE_in_field_decl210); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(43, 22);
    		PushFollow(Follow._type_in_field_decl214);
    		t=type();
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(43, 31);
    		id=(CommonTree)Match(input,ID,Follow._ID_in_field_decl219); 

    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(44, 5);

    		   		if (t != null)
    		   			members.Add(new StructMember((id!=null?id.Text:null), t));
    		   		else
    		   			members.Add(new StructMember((id!=null?id.Text:null)));
    		   	

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(50, 3);
    	} finally { DebugExitRule(GrammarFileName, "field_decl"); }
    	return;

    }
    // $ANTLR end "field_decl"


    protected virtual void Enter_type() {}
    protected virtual void Leave_type() {}

    // $ANTLR start "type"
    // IlGenWalker.g:52:1: type returns [String rt = null;] : ( INT | BOOL | ^( STRUCT id= ID ) );
    [GrammarRule("type")]
    private String type()
    {

        String rt =  null;;

        CommonTree id=null;

    	try { DebugEnterRule(GrammarFileName, "type");
    	DebugLocation(52, 0);
    	try
    	{
    		// IlGenWalker.g:53:2: ( INT | BOOL | ^( STRUCT id= ID ) )
    		int alt4=3;
    		try { DebugEnterDecision(4, decisionCanBacktrack[4]);
    		switch (input.LA(1))
    		{
    		case INT:
    			{
    			alt4=1;
    			}
    			break;
    		case BOOL:
    			{
    			alt4=2;
    			}
    			break;
    		case STRUCT:
    			{
    			alt4=3;
    			}
    			break;
    		default:
    			{
    				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);

    				DebugRecognitionException(nvae);
    				throw nvae;
    			}
    		}

    		} finally { DebugExitDecision(4); }
    		switch (alt4)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:53:4: INT
    			{
    			DebugLocation(53, 4);
    			Match(input,INT,Follow._INT_in_type244); 

    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// IlGenWalker.g:54:4: BOOL
    			{
    			DebugLocation(54, 4);
    			Match(input,BOOL,Follow._BOOL_in_type249); 

    			}
    			break;
    		case 3:
    			DebugEnterAlt(3);
    			// IlGenWalker.g:55:4: ^( STRUCT id= ID )
    			{
    			DebugLocation(55, 4);
    			DebugLocation(55, 6);
    			Match(input,STRUCT,Follow._STRUCT_in_type255); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(55, 15);
    			id=(CommonTree)Match(input,ID,Follow._ID_in_type259); 

    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(55, 20);
    			rt = (id!=null?id.Text:null);

    			}
    			break;

    		}
    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(56, 0);
    	} finally { DebugExitRule(GrammarFileName, "type"); }
    	return rt;

    }
    // $ANTLR end "type"


    protected virtual void Enter_declarations() {}
    protected virtual void Leave_declarations() {}

    // $ANTLR start "declarations"
    // IlGenWalker.g:58:1: declarations[bool isLocal, Dictionary<string, string> typeMap] : ( ^( DECLS declaration[$isLocal,$typeMap] ) | );
    [GrammarRule("declarations")]
    private void declarations(bool isLocal, Dictionary<string, string> typeMap)
    {

    	try { DebugEnterRule(GrammarFileName, "declarations");
    	DebugLocation(58, 0);
    	try
    	{
    		// IlGenWalker.g:59:2: ( ^( DECLS declaration[$isLocal,$typeMap] ) | )
    		int alt5=2;
    		try { DebugEnterDecision(5, decisionCanBacktrack[5]);
    		int LA5_0 = input.LA(1);

    		if ((LA5_0==DECLS))
    		{
    			alt5=1;
    		}
    		else if ((LA5_0==FUNCS||LA5_0==STMTS))
    		{
    			alt5=2;
    		}
    		else
    		{
    			NoViableAltException nvae = new NoViableAltException("", 5, 0, input);

    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    		} finally { DebugExitDecision(5); }
    		switch (alt5)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:59:4: ^( DECLS declaration[$isLocal,$typeMap] )
    			{
    			DebugLocation(59, 4);
    			DebugLocation(59, 6);
    			Match(input,DECLS,Follow._DECLS_in_declarations274); 

    			if (input.LA(1) == TokenTypes.Down)
    			{
    				Match(input, TokenTypes.Down, null); 
    				DebugLocation(59, 12);
    				PushFollow(Follow._declaration_in_declarations276);
    				declaration(isLocal, typeMap);
    				PopFollow();


    				Match(input, TokenTypes.Up, null); 
    			}

    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// IlGenWalker.g:61:1: 
    			{
    			}
    			break;

    		}
    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(61, 0);
    	} finally { DebugExitRule(GrammarFileName, "declarations"); }
    	return;

    }
    // $ANTLR end "declarations"


    protected virtual void Enter_declaration() {}
    protected virtual void Leave_declaration() {}

    // $ANTLR start "declaration"
    // IlGenWalker.g:63:1: declaration[bool isLocal, Dictionary<string, string> typeMap] : ( decl_list[$isLocal,$typeMap] )* ;
    [GrammarRule("declaration")]
    private void declaration(bool isLocal, Dictionary<string, string> typeMap)
    {

    	try { DebugEnterRule(GrammarFileName, "declaration");
    	DebugLocation(63, 0);
    	try
    	{
    		// IlGenWalker.g:64:2: ( ( decl_list[$isLocal,$typeMap] )* )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:64:4: ( decl_list[$isLocal,$typeMap] )*
    		{
    		DebugLocation(64, 4);
    		// IlGenWalker.g:64:4: ( decl_list[$isLocal,$typeMap] )*
    		try { DebugEnterSubRule(6);
    		while (true)
    		{
    			int alt6=2;
    			try { DebugEnterDecision(6, decisionCanBacktrack[6]);
    			int LA6_0 = input.LA(1);

    			if ((LA6_0==DECLLIST))
    			{
    				alt6=1;
    			}


    			} finally { DebugExitDecision(6); }
    			switch ( alt6 )
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// IlGenWalker.g:64:5: decl_list[$isLocal,$typeMap]
    				{
    				DebugLocation(64, 5);
    				PushFollow(Follow._decl_list_in_declaration294);
    				decl_list(isLocal, typeMap);
    				PopFollow();


    				}
    				break;

    			default:
    				goto loop6;
    			}
    		}

    		loop6:
    			;

    		} finally { DebugExitSubRule(6); }


    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(65, 0);
    	} finally { DebugExitRule(GrammarFileName, "declaration"); }
    	return;

    }
    // $ANTLR end "declaration"


    protected virtual void Enter_decl_list() {}
    protected virtual void Leave_decl_list() {}

    // $ANTLR start "decl_list"
    // IlGenWalker.g:67:1: decl_list[bool isLocal, Dictionary<string, string> typeMap] : ^( DECLLIST ^( TYPE t= type ) id_list[ids] ) ;
    [GrammarRule("decl_list")]
    private void decl_list(bool isLocal, Dictionary<string, string> typeMap)
    {

        String t = default(String);

         var ids = new List<string>(); 
    	try { DebugEnterRule(GrammarFileName, "decl_list");
    	DebugLocation(67, 0);
    	try
    	{
    		// IlGenWalker.g:69:2: ( ^( DECLLIST ^( TYPE t= type ) id_list[ids] ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:69:4: ^( DECLLIST ^( TYPE t= type ) id_list[ids] )
    		{
    		DebugLocation(69, 4);
    		DebugLocation(69, 6);
    		Match(input,DECLLIST,Follow._DECLLIST_in_decl_list314); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(69, 15);
    		DebugLocation(69, 17);
    		Match(input,TYPE,Follow._TYPE_in_decl_list317); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(69, 23);
    		PushFollow(Follow._type_in_decl_list321);
    		t=type();
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(69, 30);
    		PushFollow(Follow._id_list_in_decl_list324);
    		id_list(ids);
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(70, 3);

    					foreach (var id in ids)
    					{
    						if (isLocal)
    						{
    		          //XXX: changed to VarReg for testing reg alloc, prob should change back so that IL is SSA again so that LLVM will work
    							//localMap.Add(id, new VarLocal(id, t));
    							localMap.Add(id, new VarReg(Instruction.VirtualRegister(), t));
    						}
    						else
    						{
    							globalMap.Add(id, new VarGlobal(id, t));
    						}
    						if (t != null)
    							typeMap[id] = t;
    					}
    				

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(87, 0);
    	} finally { DebugExitRule(GrammarFileName, "decl_list"); }
    	return;

    }
    // $ANTLR end "decl_list"


    protected virtual void Enter_id_list() {}
    protected virtual void Leave_id_list() {}

    // $ANTLR start "id_list"
    // IlGenWalker.g:89:1: id_list[List<string> ids] : (id= ID )+ ;
    [GrammarRule("id_list")]
    private void id_list(List<string> ids)
    {

        CommonTree id=null;

    	try { DebugEnterRule(GrammarFileName, "id_list");
    	DebugLocation(89, 0);
    	try
    	{
    		// IlGenWalker.g:90:2: ( (id= ID )+ )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:90:4: (id= ID )+
    		{
    		DebugLocation(90, 4);
    		// IlGenWalker.g:90:4: (id= ID )+
    		int cnt7=0;
    		try { DebugEnterSubRule(7);
    		while (true)
    		{
    			int alt7=2;
    			try { DebugEnterDecision(7, decisionCanBacktrack[7]);
    			int LA7_0 = input.LA(1);

    			if ((LA7_0==ID))
    			{
    				alt7=1;
    			}


    			} finally { DebugExitDecision(7); }
    			switch (alt7)
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// IlGenWalker.g:90:5: id= ID
    				{
    				DebugLocation(90, 7);
    				id=(CommonTree)Match(input,ID,Follow._ID_in_id_list344); 
    				DebugLocation(90, 11);
    				ids.Add((id!=null?id.Text:null));

    				}
    				break;

    			default:
    				if (cnt7 >= 1)
    					goto loop7;

    				EarlyExitException eee7 = new EarlyExitException( 7, input );
    				DebugRecognitionException(eee7);
    				throw eee7;
    			}
    			cnt7++;
    		}
    		loop7:
    			;

    		} finally { DebugExitSubRule(7); }


    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(91, 0);
    	} finally { DebugExitRule(GrammarFileName, "id_list"); }
    	return;

    }
    // $ANTLR end "id_list"


    protected virtual void Enter_functions() {}
    protected virtual void Leave_functions() {}

    // $ANTLR start "functions"
    // IlGenWalker.g:93:1: functions returns [List<FunctionBlock<MilocInstruction>> funs = new List<FunctionBlock<MilocInstruction>>()] : ^( FUNCS (f= function )* ) ;
    [GrammarRule("functions")]
    private List<FunctionBlock<MilocInstruction>> functions()
    {

        List<FunctionBlock<MilocInstruction>> funs =  new List<FunctionBlock<MilocInstruction>>();

        FunctionBlock<MilocInstruction> f = default(FunctionBlock<MilocInstruction>);

    	try { DebugEnterRule(GrammarFileName, "functions");
    	DebugLocation(93, 1);
    	try
    	{
    		// IlGenWalker.g:94:2: ( ^( FUNCS (f= function )* ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:94:4: ^( FUNCS (f= function )* )
    		{
    		DebugLocation(94, 4);
    		DebugLocation(94, 6);
    		Match(input,FUNCS,Follow._FUNCS_in_functions365); 

    		if (input.LA(1) == TokenTypes.Down)
    		{
    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(94, 12);
    			// IlGenWalker.g:94:12: (f= function )*
    			try { DebugEnterSubRule(8);
    			while (true)
    			{
    				int alt8=2;
    				try { DebugEnterDecision(8, decisionCanBacktrack[8]);
    				int LA8_0 = input.LA(1);

    				if ((LA8_0==FUN))
    				{
    					alt8=1;
    				}


    				} finally { DebugExitDecision(8); }
    				switch ( alt8 )
    				{
    				case 1:
    					DebugEnterAlt(1);
    					// IlGenWalker.g:94:13: f= function
    					{
    					DebugLocation(94, 14);
    					PushFollow(Follow._function_in_functions370);
    					f=function();
    					PopFollow();

    					DebugLocation(94, 23);
    					funs.Add(f);

    					}
    					break;

    				default:
    					goto loop8;
    				}
    			}

    			loop8:
    				;

    			} finally { DebugExitSubRule(8); }


    			Match(input, TokenTypes.Up, null); 
    		}

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(95, 1);
    	} finally { DebugExitRule(GrammarFileName, "functions"); }
    	return funs;

    }
    // $ANTLR end "functions"


    protected virtual void Enter_function() {}
    protected virtual void Leave_function() {}

    // $ANTLR start "function"
    // IlGenWalker.g:97:1: function returns [FunctionBlock<MilocInstruction> f] : ^( FUN id= ID parameters[argLoadBlock] ^( RETTYPE retType= return_type ) declarations[true,localStructMap] statement_list[body] ) ;
    [GrammarRule("function")]
    private FunctionBlock<MilocInstruction> function()
    {

        FunctionBlock<MilocInstruction> f = default(FunctionBlock<MilocInstruction>);

        CommonTree id=null;
        string retType = default(string);


        		localMap.Clear();
        		localStructMap.Clear();
        		
        		SeqBlock<MilocInstruction> body = new SeqBlock<MilocInstruction>();
        		BasicBlock<MilocInstruction> argLoadBlock = new BasicBlock<MilocInstruction>();
        	
    	try { DebugEnterRule(GrammarFileName, "function");
    	DebugLocation(97, 1);
    	try
    	{
    		// IlGenWalker.g:106:2: ( ^( FUN id= ID parameters[argLoadBlock] ^( RETTYPE retType= return_type ) declarations[true,localStructMap] statement_list[body] ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:106:4: ^( FUN id= ID parameters[argLoadBlock] ^( RETTYPE retType= return_type ) declarations[true,localStructMap] statement_list[body] )
    		{
    		DebugLocation(106, 4);
    		DebugLocation(106, 6);
    		Match(input,FUN,Follow._FUN_in_function396); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(106, 12);
    		id=(CommonTree)Match(input,ID,Follow._ID_in_function400); 
    		DebugLocation(106, 16);
    		PushFollow(Follow._parameters_in_function402);
    		parameters(argLoadBlock);
    		PopFollow();

    		DebugLocation(106, 41);
    		DebugLocation(106, 43);
    		Match(input,RETTYPE,Follow._RETTYPE_in_function406); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(106, 58);
    		PushFollow(Follow._return_type_in_function410);
    		retType=return_type();
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(107, 4);

    						body.Add(argLoadBlock);
    						if (!string.IsNullOrEmpty(retType))
    						{
    							functionStructMap[(id!=null?id.Text:null)] = retType;
    						}
    					
    		DebugLocation(114, 3);
    		PushFollow(Follow._declarations_in_function420);
    		declarations(true, localStructMap);
    		PopFollow();

    		DebugLocation(114, 37);
    		PushFollow(Follow._statement_list_in_function423);
    		statement_list(body);
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(115, 3);

    					BasicBlock<MilocInstruction> returnBlock = new BasicBlock<MilocInstruction>();
    					if (retType == "<void>")
    						returnBlock.Add(new RetInstruction());
    					body.Add(returnBlock);
    					body.SetNext(new BasicBlock<MilocInstruction>());
    					f = new FunctionBlock<MilocInstruction>((id!=null?id.Text:null), body);
    					foreach (var l in localMap)
    					{
    						if (!(l.Value is VarLocal))
    							continue;
    						f.Locals.Add(l.Key);
    					}
    				

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(129, 1);
    	} finally { DebugExitRule(GrammarFileName, "function"); }
    	return f;

    }
    // $ANTLR end "function"


    protected virtual void Enter_parameters() {}
    protected virtual void Leave_parameters() {}

    // $ANTLR start "parameters"
    // IlGenWalker.g:131:1: parameters[BasicBlock<MilocInstruction> b] : ^( PARAMS ( param_decl[$b,ndx] )* ) ;
    [GrammarRule("parameters")]
    private void parameters(BasicBlock<MilocInstruction> b)
    {

        int ndx = 0;
    	try { DebugEnterRule(GrammarFileName, "parameters");
    	DebugLocation(131, 1);
    	try
    	{
    		// IlGenWalker.g:133:2: ( ^( PARAMS ( param_decl[$b,ndx] )* ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:133:4: ^( PARAMS ( param_decl[$b,ndx] )* )
    		{
    		DebugLocation(133, 4);
    		DebugLocation(133, 6);
    		Match(input,PARAMS,Follow._PARAMS_in_parameters447); 

    		if (input.LA(1) == TokenTypes.Down)
    		{
    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(133, 13);
    			// IlGenWalker.g:133:13: ( param_decl[$b,ndx] )*
    			try { DebugEnterSubRule(9);
    			while (true)
    			{
    				int alt9=2;
    				try { DebugEnterDecision(9, decisionCanBacktrack[9]);
    				int LA9_0 = input.LA(1);

    				if ((LA9_0==DECL))
    				{
    					alt9=1;
    				}


    				} finally { DebugExitDecision(9); }
    				switch ( alt9 )
    				{
    				case 1:
    					DebugEnterAlt(1);
    					// IlGenWalker.g:133:14: param_decl[$b,ndx]
    					{
    					DebugLocation(133, 14);
    					PushFollow(Follow._param_decl_in_parameters450);
    					param_decl(b, ndx);
    					PopFollow();

    					DebugLocation(133, 33);
    					ndx++;

    					}
    					break;

    				default:
    					goto loop9;
    				}
    			}

    			loop9:
    				;

    			} finally { DebugExitSubRule(9); }


    			Match(input, TokenTypes.Up, null); 
    		}

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(134, 1);
    	} finally { DebugExitRule(GrammarFileName, "parameters"); }
    	return;

    }
    // $ANTLR end "parameters"


    protected virtual void Enter_param_decl() {}
    protected virtual void Leave_param_decl() {}

    // $ANTLR start "param_decl"
    // IlGenWalker.g:136:1: param_decl[BasicBlock<MilocInstruction> b, int ndx] : ^( DECL ^( TYPE t= type ) id= ID ) ;
    [GrammarRule("param_decl")]
    private void param_decl(BasicBlock<MilocInstruction> b, int ndx)
    {

        CommonTree id=null;
        String t = default(String);

    	try { DebugEnterRule(GrammarFileName, "param_decl");
    	DebugLocation(136, 3);
    	try
    	{
    		// IlGenWalker.g:137:4: ( ^( DECL ^( TYPE t= type ) id= ID ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:137:7: ^( DECL ^( TYPE t= type ) id= ID )
    		{
    		DebugLocation(137, 7);
    		DebugLocation(137, 9);
    		Match(input,DECL,Follow._DECL_in_param_decl473); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(137, 14);
    		DebugLocation(137, 16);
    		Match(input,TYPE,Follow._TYPE_in_param_decl476); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(137, 22);
    		PushFollow(Follow._type_in_param_decl480);
    		t=type();
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(137, 31);
    		id=(CommonTree)Match(input,ID,Follow._ID_in_param_decl485); 

    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(138, 5);

    		   		int regDest = Instruction.VirtualRegister();
    		   		b.Add(new LoadinargumentInstruction((id!=null?id.Text:null), ndx, regDest));
    		   		b.Add(new StoreaiVarInstruction(regDest, (id!=null?id.Text:null)) { ArgIndex = ndx });
    		   		localMap[(id!=null?id.Text:null)] = new VarLocal((id!=null?id.Text:null), t) { ArgIndex = ndx };
    		   		
    		   		if (t != null)
    		   			localStructMap[(id!=null?id.Text:null)] = t;
    		   	

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(147, 3);
    	} finally { DebugExitRule(GrammarFileName, "param_decl"); }
    	return;

    }
    // $ANTLR end "param_decl"


    protected virtual void Enter_return_type() {}
    protected virtual void Leave_return_type() {}

    // $ANTLR start "return_type"
    // IlGenWalker.g:149:1: return_type returns [string retType = null] : (t= type | VOID );
    [GrammarRule("return_type")]
    private string return_type()
    {

        string retType =  null;

        String t = default(String);

    	try { DebugEnterRule(GrammarFileName, "return_type");
    	DebugLocation(149, 1);
    	try
    	{
    		// IlGenWalker.g:150:2: (t= type | VOID )
    		int alt10=2;
    		try { DebugEnterDecision(10, decisionCanBacktrack[10]);
    		int LA10_0 = input.LA(1);

    		if (((LA10_0>=STRUCT && LA10_0<=BOOL)))
    		{
    			alt10=1;
    		}
    		else if ((LA10_0==VOID))
    		{
    			alt10=2;
    		}
    		else
    		{
    			NoViableAltException nvae = new NoViableAltException("", 10, 0, input);

    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    		} finally { DebugExitDecision(10); }
    		switch (alt10)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:150:4: t= type
    			{
    			DebugLocation(150, 5);
    			PushFollow(Follow._type_in_return_type511);
    			t=type();
    			PopFollow();

    			DebugLocation(150, 11);
    			retType = t;

    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// IlGenWalker.g:151:4: VOID
    			{
    			DebugLocation(151, 4);
    			Match(input,VOID,Follow._VOID_in_return_type518); 
    			DebugLocation(151, 9);
    			retType = "<void>";

    			}
    			break;

    		}
    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(152, 1);
    	} finally { DebugExitRule(GrammarFileName, "return_type"); }
    	return retType;

    }
    // $ANTLR end "return_type"


    protected virtual void Enter_statement() {}
    protected virtual void Leave_statement() {}

    // $ANTLR start "statement"
    // IlGenWalker.g:154:1: statement returns [Node<MilocInstruction> node] : (s= block | b= assignment | b= print | b= read | c= conditional | l= loop | b= delete | b= ret | b= invocation );
    [GrammarRule("statement")]
    private Node<MilocInstruction> statement()
    {

        Node<MilocInstruction> node = default(Node<MilocInstruction>);

        SeqBlock<MilocInstruction> s = default(SeqBlock<MilocInstruction>);
        BasicBlock<MilocInstruction> b = default(BasicBlock<MilocInstruction>);
        IfBlock<MilocInstruction> c = default(IfBlock<MilocInstruction>);
        LoopBlock<MilocInstruction> l = default(LoopBlock<MilocInstruction>);

    	try { DebugEnterRule(GrammarFileName, "statement");
    	DebugLocation(154, 1);
    	try
    	{
    		// IlGenWalker.g:155:2: (s= block | b= assignment | b= print | b= read | c= conditional | l= loop | b= delete | b= ret | b= invocation )
    		int alt11=9;
    		try { DebugEnterDecision(11, decisionCanBacktrack[11]);
    		switch (input.LA(1))
    		{
    		case BLOCK:
    			{
    			alt11=1;
    			}
    			break;
    		case ASSIGN:
    			{
    			alt11=2;
    			}
    			break;
    		case PRINT:
    			{
    			alt11=3;
    			}
    			break;
    		case READ:
    			{
    			alt11=4;
    			}
    			break;
    		case IF:
    			{
    			alt11=5;
    			}
    			break;
    		case WHILE:
    			{
    			alt11=6;
    			}
    			break;
    		case DELETE:
    			{
    			alt11=7;
    			}
    			break;
    		case RETURN:
    			{
    			alt11=8;
    			}
    			break;
    		case INVOKE:
    			{
    			alt11=9;
    			}
    			break;
    		default:
    			{
    				NoViableAltException nvae = new NoViableAltException("", 11, 0, input);

    				DebugRecognitionException(nvae);
    				throw nvae;
    			}
    		}

    		} finally { DebugExitDecision(11); }
    		switch (alt11)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:155:4: s= block
    			{
    			DebugLocation(155, 5);
    			PushFollow(Follow._block_in_statement537);
    			s=block();
    			PopFollow();

    			DebugLocation(155, 12);
    			node = s;

    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// IlGenWalker.g:156:4: b= assignment
    			{
    			DebugLocation(156, 5);
    			PushFollow(Follow._assignment_in_statement546);
    			b=assignment();
    			PopFollow();

    			DebugLocation(156, 17);
    			node = b;

    			}
    			break;
    		case 3:
    			DebugEnterAlt(3);
    			// IlGenWalker.g:157:4: b= print
    			{
    			DebugLocation(157, 5);
    			PushFollow(Follow._print_in_statement555);
    			b=print();
    			PopFollow();

    			DebugLocation(157, 12);
    			node = b;

    			}
    			break;
    		case 4:
    			DebugEnterAlt(4);
    			// IlGenWalker.g:158:4: b= read
    			{
    			DebugLocation(158, 5);
    			PushFollow(Follow._read_in_statement564);
    			b=read();
    			PopFollow();

    			DebugLocation(158, 11);
    			node = b;

    			}
    			break;
    		case 5:
    			DebugEnterAlt(5);
    			// IlGenWalker.g:159:4: c= conditional
    			{
    			DebugLocation(159, 5);
    			PushFollow(Follow._conditional_in_statement573);
    			c=conditional();
    			PopFollow();

    			DebugLocation(159, 18);
    			node = c;

    			}
    			break;
    		case 6:
    			DebugEnterAlt(6);
    			// IlGenWalker.g:160:4: l= loop
    			{
    			DebugLocation(160, 5);
    			PushFollow(Follow._loop_in_statement582);
    			l=loop();
    			PopFollow();

    			DebugLocation(160, 11);
    			node = l;

    			}
    			break;
    		case 7:
    			DebugEnterAlt(7);
    			// IlGenWalker.g:161:4: b= delete
    			{
    			DebugLocation(161, 5);
    			PushFollow(Follow._delete_in_statement591);
    			b=delete();
    			PopFollow();

    			DebugLocation(161, 13);
    			node = b;

    			}
    			break;
    		case 8:
    			DebugEnterAlt(8);
    			// IlGenWalker.g:162:4: b= ret
    			{
    			DebugLocation(162, 5);
    			PushFollow(Follow._ret_in_statement600);
    			b=ret();
    			PopFollow();

    			DebugLocation(162, 10);
    			node = b;

    			}
    			break;
    		case 9:
    			DebugEnterAlt(9);
    			// IlGenWalker.g:163:4: b= invocation
    			{
    			DebugLocation(163, 5);
    			PushFollow(Follow._invocation_in_statement609);
    			b=invocation();
    			PopFollow();

    			DebugLocation(163, 17);
    			node = b;

    			}
    			break;

    		}
    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(164, 1);
    	} finally { DebugExitRule(GrammarFileName, "statement"); }
    	return node;

    }
    // $ANTLR end "statement"


    protected virtual void Enter_block() {}
    protected virtual void Leave_block() {}

    // $ANTLR start "block"
    // IlGenWalker.g:166:1: block returns [SeqBlock<MilocInstruction> b = new SeqBlock<MilocInstruction>()] : ^( BLOCK statement_list[$b] ) ;
    [GrammarRule("block")]
    private SeqBlock<MilocInstruction> block()
    {

        SeqBlock<MilocInstruction> b =  new SeqBlock<MilocInstruction>();

    	try { DebugEnterRule(GrammarFileName, "block");
    	DebugLocation(166, 1);
    	try
    	{
    		// IlGenWalker.g:167:2: ( ^( BLOCK statement_list[$b] ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:167:4: ^( BLOCK statement_list[$b] )
    		{
    		DebugLocation(167, 4);
    		DebugLocation(167, 6);
    		Match(input,BLOCK,Follow._BLOCK_in_block627); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(167, 12);
    		PushFollow(Follow._statement_list_in_block629);
    		statement_list(b);
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(168, 1);
    	} finally { DebugExitRule(GrammarFileName, "block"); }
    	return b;

    }
    // $ANTLR end "block"


    protected virtual void Enter_statement_list() {}
    protected virtual void Leave_statement_list() {}

    // $ANTLR start "statement_list"
    // IlGenWalker.g:170:1: statement_list[SeqBlock<MilocInstruction> b] : ^( STMTS (s= statement )* ) ;
    [GrammarRule("statement_list")]
    private void statement_list(SeqBlock<MilocInstruction> b)
    {

        Node<MilocInstruction> s = default(Node<MilocInstruction>);

    	try { DebugEnterRule(GrammarFileName, "statement_list");
    	DebugLocation(170, 1);
    	try
    	{
    		// IlGenWalker.g:171:2: ( ^( STMTS (s= statement )* ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:171:4: ^( STMTS (s= statement )* )
    		{
    		DebugLocation(171, 4);
    		DebugLocation(171, 6);
    		Match(input,STMTS,Follow._STMTS_in_statement_list644); 

    		if (input.LA(1) == TokenTypes.Down)
    		{
    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(171, 12);
    			// IlGenWalker.g:171:12: (s= statement )*
    			try { DebugEnterSubRule(12);
    			while (true)
    			{
    				int alt12=2;
    				try { DebugEnterDecision(12, decisionCanBacktrack[12]);
    				int LA12_0 = input.LA(1);

    				if ((LA12_0==PRINT||(LA12_0>=READ && LA12_0<=IF)||(LA12_0>=WHILE && LA12_0<=RETURN)||LA12_0==BLOCK||LA12_0==INVOKE||LA12_0==ASSIGN))
    				{
    					alt12=1;
    				}


    				} finally { DebugExitDecision(12); }
    				switch ( alt12 )
    				{
    				case 1:
    					DebugEnterAlt(1);
    					// IlGenWalker.g:171:13: s= statement
    					{
    					DebugLocation(171, 14);
    					PushFollow(Follow._statement_in_statement_list649);
    					s=statement();
    					PopFollow();

    					DebugLocation(172, 3);

    								if (!b.IsReturn)
    								{
    									b.Add(s);
    								}
    							

    					}
    					break;

    				default:
    					goto loop12;
    				}
    			}

    			loop12:
    				;

    			} finally { DebugExitSubRule(12); }


    			Match(input, TokenTypes.Up, null); 
    		}

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(179, 1);
    	} finally { DebugExitRule(GrammarFileName, "statement_list"); }
    	return;

    }
    // $ANTLR end "statement_list"


    protected virtual void Enter_assignment() {}
    protected virtual void Leave_assignment() {}

    // $ANTLR start "assignment"
    // IlGenWalker.g:181:1: assignment returns [BasicBlock<MilocInstruction> b = new BasicBlock<MilocInstruction>()] : ^( ASSIGN dest= lvalue[b] e= expression ) ;
    [GrammarRule("assignment")]
    private BasicBlock<MilocInstruction> assignment()
    {

        BasicBlock<MilocInstruction> b =  new BasicBlock<MilocInstruction>();

        VarBase dest = default(VarBase);
        BasicBlock<MilocInstruction> e = default(BasicBlock<MilocInstruction>);

    	try { DebugEnterRule(GrammarFileName, "assignment");
    	DebugLocation(181, 1);
    	try
    	{
    		// IlGenWalker.g:182:2: ( ^( ASSIGN dest= lvalue[b] e= expression ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:182:4: ^( ASSIGN dest= lvalue[b] e= expression )
    		{
    		DebugLocation(182, 4);
    		DebugLocation(182, 6);
    		Match(input,ASSIGN,Follow._ASSIGN_in_assignment674); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(182, 17);
    		PushFollow(Follow._lvalue_in_assignment678);
    		dest=lvalue(b);
    		PopFollow();

    		DebugLocation(182, 29);
    		PushFollow(Follow._expression_in_assignment683);
    		e=expression();
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(183, 3);

    					b.Add(e);
    					b.Add(dest.Store(e.Reg));
    				

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(187, 1);
    	} finally { DebugExitRule(GrammarFileName, "assignment"); }
    	return b;

    }
    // $ANTLR end "assignment"


    protected virtual void Enter_print() {}
    protected virtual void Leave_print() {}

    // $ANTLR start "print"
    // IlGenWalker.g:189:1: print returns [BasicBlock<MilocInstruction> b = new BasicBlock<MilocInstruction>()] : ^( PRINT e= expression (el= ENDL )? ) ;
    [GrammarRule("print")]
    private BasicBlock<MilocInstruction> print()
    {

        BasicBlock<MilocInstruction> b =  new BasicBlock<MilocInstruction>();

        CommonTree el=null;
        BasicBlock<MilocInstruction> e = default(BasicBlock<MilocInstruction>);

    	try { DebugEnterRule(GrammarFileName, "print");
    	DebugLocation(189, 1);
    	try
    	{
    		// IlGenWalker.g:190:2: ( ^( PRINT e= expression (el= ENDL )? ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:190:4: ^( PRINT e= expression (el= ENDL )? )
    		{
    		DebugLocation(190, 4);
    		DebugLocation(190, 6);
    		Match(input,PRINT,Follow._PRINT_in_print704); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(190, 13);
    		PushFollow(Follow._expression_in_print708);
    		e=expression();
    		PopFollow();

    		DebugLocation(190, 25);
    		// IlGenWalker.g:190:25: (el= ENDL )?
    		int alt13=2;
    		try { DebugEnterSubRule(13);
    		try { DebugEnterDecision(13, decisionCanBacktrack[13]);
    		int LA13_0 = input.LA(1);

    		if ((LA13_0==ENDL))
    		{
    			alt13=1;
    		}
    		} finally { DebugExitDecision(13); }
    		switch (alt13)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:190:26: el= ENDL
    			{
    			DebugLocation(190, 28);
    			el=(CommonTree)Match(input,ENDL,Follow._ENDL_in_print713); 

    			}
    			break;

    		}
    		} finally { DebugExitSubRule(13); }


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(191, 3);

    					b.Add(e);
    					if (el == null)
    						b.Add(new PrintInstruction(e.Reg));
    					else
    						b.Add(new PrintlnInstruction(e.Reg));
    				

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(198, 1);
    	} finally { DebugExitRule(GrammarFileName, "print"); }
    	return b;

    }
    // $ANTLR end "print"


    protected virtual void Enter_read() {}
    protected virtual void Leave_read() {}

    // $ANTLR start "read"
    // IlGenWalker.g:200:1: read returns [BasicBlock<MilocInstruction> b = new BasicBlock<MilocInstruction>()] : ^( READ dest= lvalue[b] ) ;
    [GrammarRule("read")]
    private BasicBlock<MilocInstruction> read()
    {

        BasicBlock<MilocInstruction> b =  new BasicBlock<MilocInstruction>();

        VarBase dest = default(VarBase);

    	try { DebugEnterRule(GrammarFileName, "read");
    	DebugLocation(200, 1);
    	try
    	{
    		// IlGenWalker.g:201:2: ( ^( READ dest= lvalue[b] ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:201:4: ^( READ dest= lvalue[b] )
    		{
    		DebugLocation(201, 4);
    		DebugLocation(201, 6);
    		Match(input,READ,Follow._READ_in_read737); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(201, 15);
    		PushFollow(Follow._lvalue_in_read741);
    		dest=lvalue(b);
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(202, 3);

    					int addressReg = Instruction.VirtualRegister();
    					int valueReg = Instruction.VirtualRegister();
    					b.Add(new ComputeglobaladdressInstruction(MilocInstruction.ReadGlobalName, addressReg));
    					b.Add(new ReadInstruction(addressReg));
    					b.Add(new LoadglobalInstruction(MilocInstruction.ReadGlobalName, valueReg));
    					b.Add(dest.Store(valueReg));
    				

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(210, 1);
    	} finally { DebugExitRule(GrammarFileName, "read"); }
    	return b;

    }
    // $ANTLR end "read"


    protected virtual void Enter_conditional() {}
    protected virtual void Leave_conditional() {}

    // $ANTLR start "conditional"
    // IlGenWalker.g:212:1: conditional returns [IfBlock<MilocInstruction> b] : ^( IF e= expression t= block (f= block )? ) ;
    [GrammarRule("conditional")]
    private IfBlock<MilocInstruction> conditional()
    {

        IfBlock<MilocInstruction> b = default(IfBlock<MilocInstruction>);

        BasicBlock<MilocInstruction> e = default(BasicBlock<MilocInstruction>);
        SeqBlock<MilocInstruction> t = default(SeqBlock<MilocInstruction>);
        SeqBlock<MilocInstruction> f = default(SeqBlock<MilocInstruction>);

         var lab = new Label(); 
    	try { DebugEnterRule(GrammarFileName, "conditional");
    	DebugLocation(212, 1);
    	try
    	{
    		// IlGenWalker.g:214:2: ( ^( IF e= expression t= block (f= block )? ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:214:4: ^( IF e= expression t= block (f= block )? )
    		{
    		DebugLocation(214, 4);
    		DebugLocation(214, 6);
    		Match(input,IF,Follow._IF_in_conditional768); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(214, 10);
    		PushFollow(Follow._expression_in_conditional772);
    		e=expression();
    		PopFollow();

    		DebugLocation(214, 23);
    		PushFollow(Follow._block_in_conditional776);
    		t=block();
    		PopFollow();

    		DebugLocation(214, 30);
    		// IlGenWalker.g:214:30: (f= block )?
    		int alt14=2;
    		try { DebugEnterSubRule(14);
    		try { DebugEnterDecision(14, decisionCanBacktrack[14]);
    		int LA14_0 = input.LA(1);

    		if ((LA14_0==BLOCK))
    		{
    			alt14=1;
    		}
    		} finally { DebugExitDecision(14); }
    		switch (alt14)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:214:31: f= block
    			{
    			DebugLocation(214, 32);
    			PushFollow(Follow._block_in_conditional781);
    			f=block();
    			PopFollow();


    			}
    			break;

    		}
    		} finally { DebugExitSubRule(14); }


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(215, 3);

    					int reg = Instruction.VirtualRegister();
    					f = f ?? new SeqBlock<MilocInstruction>();
    					
    					e.Add(new LoadiInstruction(1, reg));
    					e.Add(new CompInstruction(e.Reg, reg));
    					e.Add(new CbreqInstruction(t.Label, f.Label));
    					
    					t.Add(new JumpiInstruction(lab));
    					f.Add(new JumpiInstruction(lab));
    					
    					b = new IfBlock<MilocInstruction>(e, t, f ?? new SeqBlock<MilocInstruction>(), lab);
    				

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(228, 1);
    	} finally { DebugExitRule(GrammarFileName, "conditional"); }
    	return b;

    }
    // $ANTLR end "conditional"


    protected virtual void Enter_loop() {}
    protected virtual void Leave_loop() {}

    // $ANTLR start "loop"
    // IlGenWalker.g:230:1: loop returns [LoopBlock<MilocInstruction> b] : ^( WHILE e= expression body= block expression ) ;
    [GrammarRule("loop")]
    private LoopBlock<MilocInstruction> loop()
    {

        LoopBlock<MilocInstruction> b = default(LoopBlock<MilocInstruction>);

        BasicBlock<MilocInstruction> e = default(BasicBlock<MilocInstruction>);
        SeqBlock<MilocInstruction> body = default(SeqBlock<MilocInstruction>);

         var lab = new Label(); 
    	try { DebugEnterRule(GrammarFileName, "loop");
    	DebugLocation(230, 1);
    	try
    	{
    		// IlGenWalker.g:232:2: ( ^( WHILE e= expression body= block expression ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:232:4: ^( WHILE e= expression body= block expression )
    		{
    		DebugLocation(232, 4);
    		DebugLocation(232, 6);
    		Match(input,WHILE,Follow._WHILE_in_loop809); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(232, 13);
    		PushFollow(Follow._expression_in_loop813);
    		e=expression();
    		PopFollow();

    		DebugLocation(232, 29);
    		PushFollow(Follow._block_in_loop817);
    		body=block();
    		PopFollow();

    		DebugLocation(232, 36);
    		PushFollow(Follow._expression_in_loop819);
    		expression();
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(233, 3);

    					body.Add(new JumpiInstruction(e.Label));
    					
    					int reg = Instruction.VirtualRegister();
    					e.Add(new LoadiInstruction(1, reg));
    					e.Add(new CompInstruction(e.Reg, reg));
    					e.Add(new CbreqInstruction(body.Label, lab));			
    					
    					b = new LoopBlock<MilocInstruction>(e, body, lab);
    				

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(243, 1);
    	} finally { DebugExitRule(GrammarFileName, "loop"); }
    	return b;

    }
    // $ANTLR end "loop"


    protected virtual void Enter_delete() {}
    protected virtual void Leave_delete() {}

    // $ANTLR start "delete"
    // IlGenWalker.g:245:1: delete returns [BasicBlock<MilocInstruction> b = new BasicBlock<MilocInstruction>()] : ^( DELETE e= expression ) ;
    [GrammarRule("delete")]
    private BasicBlock<MilocInstruction> delete()
    {

        BasicBlock<MilocInstruction> b =  new BasicBlock<MilocInstruction>();

        BasicBlock<MilocInstruction> e = default(BasicBlock<MilocInstruction>);

    	try { DebugEnterRule(GrammarFileName, "delete");
    	DebugLocation(245, 1);
    	try
    	{
    		// IlGenWalker.g:246:2: ( ^( DELETE e= expression ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:246:4: ^( DELETE e= expression )
    		{
    		DebugLocation(246, 4);
    		DebugLocation(246, 6);
    		Match(input,DELETE,Follow._DELETE_in_delete840); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(246, 14);
    		PushFollow(Follow._expression_in_delete844);
    		e=expression();
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(246, 27);
    		b.Add(e); b.Add(new DelInstruction(e.Reg));

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(247, 1);
    	} finally { DebugExitRule(GrammarFileName, "delete"); }
    	return b;

    }
    // $ANTLR end "delete"


    protected virtual void Enter_ret() {}
    protected virtual void Leave_ret() {}

    // $ANTLR start "ret"
    // IlGenWalker.g:249:1: ret returns [BasicBlock<MilocInstruction> b = new BasicBlock<MilocInstruction>()] : ^( RETURN (e= expression )? ) ;
    [GrammarRule("ret")]
    private BasicBlock<MilocInstruction> ret()
    {

        BasicBlock<MilocInstruction> b =  new BasicBlock<MilocInstruction>();

        BasicBlock<MilocInstruction> e = default(BasicBlock<MilocInstruction>);

    	try { DebugEnterRule(GrammarFileName, "ret");
    	DebugLocation(249, 1);
    	try
    	{
    		// IlGenWalker.g:250:2: ( ^( RETURN (e= expression )? ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:250:4: ^( RETURN (e= expression )? )
    		{
    		DebugLocation(250, 4);
    		DebugLocation(250, 6);
    		Match(input,RETURN,Follow._RETURN_in_ret863); 

    		if (input.LA(1) == TokenTypes.Down)
    		{
    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(250, 13);
    			// IlGenWalker.g:250:13: (e= expression )?
    			int alt15=2;
    			try { DebugEnterSubRule(15);
    			try { DebugEnterDecision(15, decisionCanBacktrack[15]);
    			int LA15_0 = input.LA(1);

    			if (((LA15_0>=TRUE && LA15_0<=NULL)||LA15_0==INVOKE||LA15_0==NEG||(LA15_0>=DOT && LA15_0<=INTEGER)))
    			{
    				alt15=1;
    			}
    			} finally { DebugExitDecision(15); }
    			switch (alt15)
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// IlGenWalker.g:250:14: e= expression
    				{
    				DebugLocation(250, 15);
    				PushFollow(Follow._expression_in_ret868);
    				e=expression();
    				PopFollow();


    				}
    				break;

    			}
    			} finally { DebugExitSubRule(15); }


    			Match(input, TokenTypes.Up, null); 
    		}
    		DebugLocation(251, 3);

    					if (e != null)
    					{
    						b.Add(e);
    						b.Add(new StoreretInstruction(e.Reg));
    					}
    					else
    						b.Add(new RetInstruction());
    					b.IsReturn = true;
    				

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(261, 1);
    	} finally { DebugExitRule(GrammarFileName, "ret"); }
    	return b;

    }
    // $ANTLR end "ret"


    protected virtual void Enter_invocation() {}
    protected virtual void Leave_invocation() {}

    // $ANTLR start "invocation"
    // IlGenWalker.g:263:1: invocation returns [BasicBlock<MilocInstruction> b = new BasicBlock<MilocInstruction>()] : ^( INVOKE id= ID regLocs= arguments[$b] ) ;
    [GrammarRule("invocation")]
    private BasicBlock<MilocInstruction> invocation()
    {

        BasicBlock<MilocInstruction> b =  new BasicBlock<MilocInstruction>();

        CommonTree id=null;
        List<int> regLocs = default(List<int>);

    	try { DebugEnterRule(GrammarFileName, "invocation");
    	DebugLocation(263, 1);
    	try
    	{
    		// IlGenWalker.g:264:2: ( ^( INVOKE id= ID regLocs= arguments[$b] ) )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:264:4: ^( INVOKE id= ID regLocs= arguments[$b] )
    		{
    		DebugLocation(264, 4);
    		DebugLocation(264, 6);
    		Match(input,INVOKE,Follow._INVOKE_in_invocation892); 

    		Match(input, TokenTypes.Down, null); 
    		DebugLocation(264, 15);
    		id=(CommonTree)Match(input,ID,Follow._ID_in_invocation896); 
    		DebugLocation(264, 26);
    		PushFollow(Follow._arguments_in_invocation900);
    		regLocs=arguments(b);
    		PopFollow();


    		Match(input, TokenTypes.Up, null); 
    		DebugLocation(264, 42);
    		doInvoke((id!=null?id.Text:null), b, regLocs); 

    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(265, 1);
    	} finally { DebugExitRule(GrammarFileName, "invocation"); }
    	return b;

    }
    // $ANTLR end "invocation"


    protected virtual void Enter_lvalue() {}
    protected virtual void Leave_lvalue() {}

    // $ANTLR start "lvalue"
    // IlGenWalker.g:268:1: lvalue[BasicBlock<MilocInstruction> b] returns [VarBase dest] : ( ^( DOT lv= lvalue[b] id= ID ) | id= ID );
    [GrammarRule("lvalue")]
    private VarBase lvalue(BasicBlock<MilocInstruction> b)
    {

        VarBase dest = default(VarBase);

        CommonTree id=null;
        VarBase lv = default(VarBase);

    	try { DebugEnterRule(GrammarFileName, "lvalue");
    	DebugLocation(268, 1);
    	try
    	{
    		// IlGenWalker.g:269:2: ( ^( DOT lv= lvalue[b] id= ID ) | id= ID )
    		int alt16=2;
    		try { DebugEnterDecision(16, decisionCanBacktrack[16]);
    		int LA16_0 = input.LA(1);

    		if ((LA16_0==DOT))
    		{
    			alt16=1;
    		}
    		else if ((LA16_0==ID))
    		{
    			alt16=2;
    		}
    		else
    		{
    			NoViableAltException nvae = new NoViableAltException("", 16, 0, input);

    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    		} finally { DebugExitDecision(16); }
    		switch (alt16)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:269:4: ^( DOT lv= lvalue[b] id= ID )
    			{
    			DebugLocation(269, 4);
    			DebugLocation(269, 6);
    			Match(input,DOT,Follow._DOT_in_lvalue922); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(269, 12);
    			PushFollow(Follow._lvalue_in_lvalue926);
    			lv=lvalue(b);
    			PopFollow();

    			DebugLocation(269, 25);
    			id=(CommonTree)Match(input,ID,Follow._ID_in_lvalue931); 

    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(270, 3);

    						var reg = Instruction.VirtualRegister();
    						b.Add(lv.Load(reg));
    						dest = new VarField((id!=null?id.Text:null), reg, getMemberType(lv.Type, (id!=null?id.Text:null)), getFieldIndex(lv.Type, (id!=null?id.Text:null)));
    						
    					

    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// IlGenWalker.g:276:4: id= ID
    			{
    			DebugLocation(276, 6);
    			id=(CommonTree)Match(input,ID,Follow._ID_in_lvalue943); 
    			DebugLocation(276, 10);
    			dest = getVarReg((id!=null?id.Text:null)); 

    			}
    			break;

    		}
    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(277, 1);
    	} finally { DebugExitRule(GrammarFileName, "lvalue"); }
    	return dest;

    }
    // $ANTLR end "lvalue"


    protected virtual void Enter_expression() {}
    protected virtual void Leave_expression() {}

    // $ANTLR start "expression"
    // IlGenWalker.g:279:1: expression returns [BasicBlock<MilocInstruction> b = new BasicBlock<MilocInstruction>()] : ( ^( AND e1= expression e2= expression ) | ^( OR e1= expression e2= expression ) | ^( EQ e1= expression e2= expression ) | ^( LT e1= expression e2= expression ) | ^( GT e1= expression e2= expression ) | ^( NE e1= expression e2= expression ) | ^( LE e1= expression e2= expression ) | ^( GE e1= expression e2= expression ) | ^( PLUS e1= expression e2= expression ) | ^( MINUS e1= expression e2= expression ) | ^( TIMES e1= expression e2= expression ) | ^( DIVIDE e1= expression e2= expression ) | ^( NOT e= expression ) | ^( NEG e= expression ) | s= selector );
    [GrammarRule("expression")]
    private BasicBlock<MilocInstruction> expression()
    {

        BasicBlock<MilocInstruction> b =  new BasicBlock<MilocInstruction>();

        BasicBlock<MilocInstruction> e1 = default(BasicBlock<MilocInstruction>);
        BasicBlock<MilocInstruction> e2 = default(BasicBlock<MilocInstruction>);
        BasicBlock<MilocInstruction> e = default(BasicBlock<MilocInstruction>);
        BasicBlock<MilocInstruction> s = default(BasicBlock<MilocInstruction>);

         int reg = Instruction.VirtualRegister(); b.Reg = reg; 
    	try { DebugEnterRule(GrammarFileName, "expression");
    	DebugLocation(279, 1);
    	try
    	{
    		// IlGenWalker.g:281:2: ( ^( AND e1= expression e2= expression ) | ^( OR e1= expression e2= expression ) | ^( EQ e1= expression e2= expression ) | ^( LT e1= expression e2= expression ) | ^( GT e1= expression e2= expression ) | ^( NE e1= expression e2= expression ) | ^( LE e1= expression e2= expression ) | ^( GE e1= expression e2= expression ) | ^( PLUS e1= expression e2= expression ) | ^( MINUS e1= expression e2= expression ) | ^( TIMES e1= expression e2= expression ) | ^( DIVIDE e1= expression e2= expression ) | ^( NOT e= expression ) | ^( NEG e= expression ) | s= selector )
    		int alt17=15;
    		try { DebugEnterDecision(17, decisionCanBacktrack[17]);
    		switch (input.LA(1))
    		{
    		case AND:
    			{
    			alt17=1;
    			}
    			break;
    		case OR:
    			{
    			alt17=2;
    			}
    			break;
    		case EQ:
    			{
    			alt17=3;
    			}
    			break;
    		case LT:
    			{
    			alt17=4;
    			}
    			break;
    		case GT:
    			{
    			alt17=5;
    			}
    			break;
    		case NE:
    			{
    			alt17=6;
    			}
    			break;
    		case LE:
    			{
    			alt17=7;
    			}
    			break;
    		case GE:
    			{
    			alt17=8;
    			}
    			break;
    		case PLUS:
    			{
    			alt17=9;
    			}
    			break;
    		case MINUS:
    			{
    			alt17=10;
    			}
    			break;
    		case TIMES:
    			{
    			alt17=11;
    			}
    			break;
    		case DIVIDE:
    			{
    			alt17=12;
    			}
    			break;
    		case NOT:
    			{
    			alt17=13;
    			}
    			break;
    		case NEG:
    			{
    			alt17=14;
    			}
    			break;
    		case TRUE:
    		case FALSE:
    		case NEW:
    		case NULL:
    		case INVOKE:
    		case DOT:
    		case ID:
    		case INTEGER:
    			{
    			alt17=15;
    			}
    			break;
    		default:
    			{
    				NoViableAltException nvae = new NoViableAltException("", 17, 0, input);

    				DebugRecognitionException(nvae);
    				throw nvae;
    			}
    		}

    		} finally { DebugExitDecision(17); }
    		switch (alt17)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:281:4: ^( AND e1= expression e2= expression )
    			{
    			DebugLocation(281, 4);
    			DebugLocation(281, 6);
    			Match(input,AND,Follow._AND_in_expression966); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(281, 12);
    			PushFollow(Follow._expression_in_expression970);
    			e1=expression();
    			PopFollow();

    			DebugLocation(281, 26);
    			PushFollow(Follow._expression_in_expression974);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(281, 39);
    			 b.Add(e1); b.Add(e2); b.Add(new AndInstruction(e1.Reg, e2.Reg, reg)); 

    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// IlGenWalker.g:282:4: ^( OR e1= expression e2= expression )
    			{
    			DebugLocation(282, 4);
    			DebugLocation(282, 6);
    			Match(input,OR,Follow._OR_in_expression983); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(282, 11);
    			PushFollow(Follow._expression_in_expression987);
    			e1=expression();
    			PopFollow();

    			DebugLocation(282, 25);
    			PushFollow(Follow._expression_in_expression991);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(282, 38);
    			 b.Add(e1); b.Add(e2); b.Add(new OrInstruction(e1.Reg, e2.Reg, reg)); 

    			}
    			break;
    		case 3:
    			DebugEnterAlt(3);
    			// IlGenWalker.g:283:4: ^( EQ e1= expression e2= expression )
    			{
    			DebugLocation(283, 4);
    			DebugLocation(283, 6);
    			Match(input,EQ,Follow._EQ_in_expression1000); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(283, 11);
    			PushFollow(Follow._expression_in_expression1004);
    			e1=expression();
    			PopFollow();

    			DebugLocation(283, 25);
    			PushFollow(Follow._expression_in_expression1008);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(283, 38);
    			 b.Add(e1); b.Add(e2); b.Add(new LoadiInstruction(0, reg)); b.Add(new CompInstruction(e1.Reg, e2.Reg)); b.Add(new MoveqInstruction(1, reg)); 

    			}
    			break;
    		case 4:
    			DebugEnterAlt(4);
    			// IlGenWalker.g:284:4: ^( LT e1= expression e2= expression )
    			{
    			DebugLocation(284, 4);
    			DebugLocation(284, 6);
    			Match(input,LT,Follow._LT_in_expression1017); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(284, 11);
    			PushFollow(Follow._expression_in_expression1021);
    			e1=expression();
    			PopFollow();

    			DebugLocation(284, 25);
    			PushFollow(Follow._expression_in_expression1025);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(284, 38);
    			 b.Add(e1); b.Add(e2); b.Add(new LoadiInstruction(0, reg)); b.Add(new CompInstruction(e1.Reg, e2.Reg)); b.Add(new MovltInstruction(1, reg)); 

    			}
    			break;
    		case 5:
    			DebugEnterAlt(5);
    			// IlGenWalker.g:285:4: ^( GT e1= expression e2= expression )
    			{
    			DebugLocation(285, 4);
    			DebugLocation(285, 6);
    			Match(input,GT,Follow._GT_in_expression1034); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(285, 11);
    			PushFollow(Follow._expression_in_expression1038);
    			e1=expression();
    			PopFollow();

    			DebugLocation(285, 25);
    			PushFollow(Follow._expression_in_expression1042);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(285, 38);
    			 b.Add(e1); b.Add(e2); b.Add(new LoadiInstruction(0, reg)); b.Add(new CompInstruction(e1.Reg, e2.Reg)); b.Add(new MovgtInstruction(1, reg)); 

    			}
    			break;
    		case 6:
    			DebugEnterAlt(6);
    			// IlGenWalker.g:286:4: ^( NE e1= expression e2= expression )
    			{
    			DebugLocation(286, 4);
    			DebugLocation(286, 6);
    			Match(input,NE,Follow._NE_in_expression1051); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(286, 11);
    			PushFollow(Follow._expression_in_expression1055);
    			e1=expression();
    			PopFollow();

    			DebugLocation(286, 25);
    			PushFollow(Follow._expression_in_expression1059);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(286, 38);
    			 b.Add(e1); b.Add(e2); b.Add(new LoadiInstruction(0, reg)); b.Add(new CompInstruction(e1.Reg, e2.Reg)); b.Add(new MovneInstruction(1, reg)); 

    			}
    			break;
    		case 7:
    			DebugEnterAlt(7);
    			// IlGenWalker.g:287:4: ^( LE e1= expression e2= expression )
    			{
    			DebugLocation(287, 4);
    			DebugLocation(287, 6);
    			Match(input,LE,Follow._LE_in_expression1068); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(287, 11);
    			PushFollow(Follow._expression_in_expression1072);
    			e1=expression();
    			PopFollow();

    			DebugLocation(287, 25);
    			PushFollow(Follow._expression_in_expression1076);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(287, 38);
    			 b.Add(e1); b.Add(e2); b.Add(new LoadiInstruction(0, reg)); b.Add(new CompInstruction(e1.Reg, e2.Reg)); b.Add(new MovleInstruction(1, reg)); 

    			}
    			break;
    		case 8:
    			DebugEnterAlt(8);
    			// IlGenWalker.g:288:4: ^( GE e1= expression e2= expression )
    			{
    			DebugLocation(288, 4);
    			DebugLocation(288, 6);
    			Match(input,GE,Follow._GE_in_expression1085); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(288, 11);
    			PushFollow(Follow._expression_in_expression1089);
    			e1=expression();
    			PopFollow();

    			DebugLocation(288, 25);
    			PushFollow(Follow._expression_in_expression1093);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(288, 38);
    			 b.Add(e1); b.Add(e2); b.Add(new LoadiInstruction(0, reg)); b.Add(new CompInstruction(e1.Reg, e2.Reg)); b.Add(new MovgeInstruction(1, reg)); 

    			}
    			break;
    		case 9:
    			DebugEnterAlt(9);
    			// IlGenWalker.g:289:4: ^( PLUS e1= expression e2= expression )
    			{
    			DebugLocation(289, 4);
    			DebugLocation(289, 6);
    			Match(input,PLUS,Follow._PLUS_in_expression1102); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(289, 13);
    			PushFollow(Follow._expression_in_expression1106);
    			e1=expression();
    			PopFollow();

    			DebugLocation(289, 27);
    			PushFollow(Follow._expression_in_expression1110);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(289, 40);
    			 b.Add(e1); b.Add(e2); b.Add(new AddInstruction(e1.Reg, e2.Reg, reg)); 

    			}
    			break;
    		case 10:
    			DebugEnterAlt(10);
    			// IlGenWalker.g:290:4: ^( MINUS e1= expression e2= expression )
    			{
    			DebugLocation(290, 4);
    			DebugLocation(290, 6);
    			Match(input,MINUS,Follow._MINUS_in_expression1119); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(290, 14);
    			PushFollow(Follow._expression_in_expression1123);
    			e1=expression();
    			PopFollow();

    			DebugLocation(290, 28);
    			PushFollow(Follow._expression_in_expression1127);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(290, 41);
    			 b.Add(e1); b.Add(e2); b.Add(new SubInstruction(e1.Reg, e2.Reg, reg)); 

    			}
    			break;
    		case 11:
    			DebugEnterAlt(11);
    			// IlGenWalker.g:291:4: ^( TIMES e1= expression e2= expression )
    			{
    			DebugLocation(291, 4);
    			DebugLocation(291, 6);
    			Match(input,TIMES,Follow._TIMES_in_expression1136); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(291, 14);
    			PushFollow(Follow._expression_in_expression1140);
    			e1=expression();
    			PopFollow();

    			DebugLocation(291, 28);
    			PushFollow(Follow._expression_in_expression1144);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(291, 41);
    			 b.Add(e1); b.Add(e2); b.Add(new MultInstruction(e1.Reg, e2.Reg, reg)); 

    			}
    			break;
    		case 12:
    			DebugEnterAlt(12);
    			// IlGenWalker.g:292:4: ^( DIVIDE e1= expression e2= expression )
    			{
    			DebugLocation(292, 4);
    			DebugLocation(292, 6);
    			Match(input,DIVIDE,Follow._DIVIDE_in_expression1153); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(292, 15);
    			PushFollow(Follow._expression_in_expression1157);
    			e1=expression();
    			PopFollow();

    			DebugLocation(292, 29);
    			PushFollow(Follow._expression_in_expression1161);
    			e2=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(292, 42);
    			 b.Add(e1); b.Add(e2); b.Add(new DivInstruction(e1.Reg, e2.Reg, reg)); 

    			}
    			break;
    		case 13:
    			DebugEnterAlt(13);
    			// IlGenWalker.g:293:4: ^( NOT e= expression )
    			{
    			DebugLocation(293, 4);
    			DebugLocation(293, 6);
    			Match(input,NOT,Follow._NOT_in_expression1170); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(293, 11);
    			PushFollow(Follow._expression_in_expression1174);
    			e=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(293, 24);
    			 b.Add(e); b.Add(new XoriInstruction(e.Reg, 1, reg)); 

    			}
    			break;
    		case 14:
    			DebugEnterAlt(14);
    			// IlGenWalker.g:294:4: ^( NEG e= expression )
    			{
    			DebugLocation(294, 4);
    			DebugLocation(294, 6);
    			Match(input,NEG,Follow._NEG_in_expression1183); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(294, 11);
    			PushFollow(Follow._expression_in_expression1187);
    			e=expression();
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 

    			}
    			break;
    		case 15:
    			DebugEnterAlt(15);
    			// IlGenWalker.g:295:4: s= selector
    			{
    			DebugLocation(295, 5);
    			PushFollow(Follow._selector_in_expression1195);
    			s=selector();
    			PopFollow();

    			DebugLocation(295, 15);
    			 b = s; 

    			}
    			break;

    		}
    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(296, 1);
    	} finally { DebugExitRule(GrammarFileName, "expression"); }
    	return b;

    }
    // $ANTLR end "expression"


    protected virtual void Enter_selector() {}
    protected virtual void Leave_selector() {}

    // $ANTLR start "selector"
    // IlGenWalker.g:298:1: selector returns [BasicBlock<MilocInstruction> b] : ( ^( DOT s= selector id= ID ) | f= factor );
    [GrammarRule("selector")]
    private BasicBlock<MilocInstruction> selector()
    {

        BasicBlock<MilocInstruction> b = default(BasicBlock<MilocInstruction>);

        CommonTree id=null;
        BasicBlock<MilocInstruction> s = default(BasicBlock<MilocInstruction>);
        BasicBlock<MilocInstruction> f = default(BasicBlock<MilocInstruction>);

    	try { DebugEnterRule(GrammarFileName, "selector");
    	DebugLocation(298, 1);
    	try
    	{
    		// IlGenWalker.g:299:2: ( ^( DOT s= selector id= ID ) | f= factor )
    		int alt18=2;
    		try { DebugEnterDecision(18, decisionCanBacktrack[18]);
    		int LA18_0 = input.LA(1);

    		if ((LA18_0==DOT))
    		{
    			alt18=1;
    		}
    		else if (((LA18_0>=TRUE && LA18_0<=NULL)||LA18_0==INVOKE||(LA18_0>=ID && LA18_0<=INTEGER)))
    		{
    			alt18=2;
    		}
    		else
    		{
    			NoViableAltException nvae = new NoViableAltException("", 18, 0, input);

    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    		} finally { DebugExitDecision(18); }
    		switch (alt18)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:299:4: ^( DOT s= selector id= ID )
    			{
    			DebugLocation(299, 4);
    			DebugLocation(299, 6);
    			Match(input,DOT,Follow._DOT_in_selector1213); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(299, 11);
    			PushFollow(Follow._selector_in_selector1217);
    			s=selector();
    			PopFollow();

    			DebugLocation(299, 23);
    			id=(CommonTree)Match(input,ID,Follow._ID_in_selector1221); 

    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(300, 3);

    						b = new BasicBlock<MilocInstruction>();
    						int reg = Instruction.VirtualRegister();
    						b.Reg = reg;
    						b.Add(s);
    						b.Add(new LoadaiFieldInstruction(s.Reg, (id!=null?id.Text:null), reg) { FieldIndex = getFieldIndex(s.StructType, (id!=null?id.Text:null)) });
    						b.StructType = getMemberType(s.StructType, (id!=null?id.Text:null));
    					

    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// IlGenWalker.g:308:4: f= factor
    			{
    			DebugLocation(308, 5);
    			PushFollow(Follow._factor_in_selector1233);
    			f=factor();
    			PopFollow();

    			DebugLocation(308, 13);
    			b = f;

    			}
    			break;

    		}
    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(309, 1);
    	} finally { DebugExitRule(GrammarFileName, "selector"); }
    	return b;

    }
    // $ANTLR end "selector"


    protected virtual void Enter_factor() {}
    protected virtual void Leave_factor() {}

    // $ANTLR start "factor"
    // IlGenWalker.g:311:1: factor returns [BasicBlock<MilocInstruction> b = new BasicBlock<MilocInstruction>()] : ( ^( INVOKE id= ID regLocs= arguments[b] ) | id= ID | i= INTEGER | TRUE | FALSE | ^( NEW id= ID ) | NULL );
    [GrammarRule("factor")]
    private BasicBlock<MilocInstruction> factor()
    {

        BasicBlock<MilocInstruction> b =  new BasicBlock<MilocInstruction>();

        CommonTree id=null;
        CommonTree i=null;
        List<int> regLocs = default(List<int>);

         int reg = Instruction.VirtualRegister(); b.Reg = reg; 
    	try { DebugEnterRule(GrammarFileName, "factor");
    	DebugLocation(311, 1);
    	try
    	{
    		// IlGenWalker.g:313:2: ( ^( INVOKE id= ID regLocs= arguments[b] ) | id= ID | i= INTEGER | TRUE | FALSE | ^( NEW id= ID ) | NULL )
    		int alt19=7;
    		try { DebugEnterDecision(19, decisionCanBacktrack[19]);
    		switch (input.LA(1))
    		{
    		case INVOKE:
    			{
    			alt19=1;
    			}
    			break;
    		case ID:
    			{
    			alt19=2;
    			}
    			break;
    		case INTEGER:
    			{
    			alt19=3;
    			}
    			break;
    		case TRUE:
    			{
    			alt19=4;
    			}
    			break;
    		case FALSE:
    			{
    			alt19=5;
    			}
    			break;
    		case NEW:
    			{
    			alt19=6;
    			}
    			break;
    		case NULL:
    			{
    			alt19=7;
    			}
    			break;
    		default:
    			{
    				NoViableAltException nvae = new NoViableAltException("", 19, 0, input);

    				DebugRecognitionException(nvae);
    				throw nvae;
    			}
    		}

    		} finally { DebugExitDecision(19); }
    		switch (alt19)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:313:4: ^( INVOKE id= ID regLocs= arguments[b] )
    			{
    			DebugLocation(313, 4);
    			DebugLocation(313, 6);
    			Match(input,INVOKE,Follow._INVOKE_in_factor1256); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(313, 15);
    			id=(CommonTree)Match(input,ID,Follow._ID_in_factor1260); 
    			DebugLocation(313, 26);
    			PushFollow(Follow._arguments_in_factor1264);
    			regLocs=arguments(b);
    			PopFollow();


    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(314, 3);

    						doInvoke((id!=null?id.Text:null), b, regLocs);
    						b.Add(new LoadretInstruction(reg));
    						if (functionStructMap.ContainsKey((id!=null?id.Text:null)))
    						{
    							b.StructType = functionStructMap[(id!=null?id.Text:null)];
    						}
    					

    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// IlGenWalker.g:322:4: id= ID
    			{
    			DebugLocation(322, 6);
    			id=(CommonTree)Match(input,ID,Follow._ID_in_factor1277); 
    			DebugLocation(323, 3);

    						b = getVarReg((id!=null?id.Text:null)).Load(reg);
    						b.StructType = getVarType((id!=null?id.Text:null));
    					

    			}
    			break;
    		case 3:
    			DebugEnterAlt(3);
    			// IlGenWalker.g:327:4: i= INTEGER
    			{
    			DebugLocation(327, 5);
    			i=(CommonTree)Match(input,INTEGER,Follow._INTEGER_in_factor1288); 
    			DebugLocation(327, 14);
    			b.Add(new LoadiInstruction(int.Parse((i!=null?i.Text:null)), reg)); 

    			}
    			break;
    		case 4:
    			DebugEnterAlt(4);
    			// IlGenWalker.g:328:4: TRUE
    			{
    			DebugLocation(328, 4);
    			Match(input,TRUE,Follow._TRUE_in_factor1295); 
    			DebugLocation(328, 9);
    			b.Add(new LoadiInstruction(1, reg)); 

    			}
    			break;
    		case 5:
    			DebugEnterAlt(5);
    			// IlGenWalker.g:329:4: FALSE
    			{
    			DebugLocation(329, 4);
    			Match(input,FALSE,Follow._FALSE_in_factor1302); 
    			DebugLocation(329, 10);
    			b.Add(new LoadiInstruction(0, reg)); 

    			}
    			break;
    		case 6:
    			DebugEnterAlt(6);
    			// IlGenWalker.g:330:4: ^( NEW id= ID )
    			{
    			DebugLocation(330, 4);
    			DebugLocation(330, 6);
    			Match(input,NEW,Follow._NEW_in_factor1310); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(330, 12);
    			id=(CommonTree)Match(input,ID,Follow._ID_in_factor1314); 

    			Match(input, TokenTypes.Up, null); 
    			DebugLocation(330, 17);
    			b.Add(new NewInstruction((id!=null?id.Text:null), getFields((id!=null?id.Text:null)), reg)); b.StructType = (id!=null?id.Text:null); 

    			}
    			break;
    		case 7:
    			DebugEnterAlt(7);
    			// IlGenWalker.g:331:4: NULL
    			{
    			DebugLocation(331, 4);
    			Match(input,NULL,Follow._NULL_in_factor1322); 
    			DebugLocation(331, 9);
    			b.Add(new LoadiInstruction(0, reg)); 

    			}
    			break;

    		}
    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(332, 1);
    	} finally { DebugExitRule(GrammarFileName, "factor"); }
    	return b;

    }
    // $ANTLR end "factor"


    protected virtual void Enter_arguments() {}
    protected virtual void Leave_arguments() {}

    // $ANTLR start "arguments"
    // IlGenWalker.g:334:1: arguments[BasicBlock<MilocInstruction> b] returns [List<int> regLocs = new List<int>()] : arg_list[$b, $regLocs] ;
    [GrammarRule("arguments")]
    private List<int> arguments(BasicBlock<MilocInstruction> b)
    {

        List<int> regLocs =  new List<int>();

    	try { DebugEnterRule(GrammarFileName, "arguments");
    	DebugLocation(334, 1);
    	try
    	{
    		// IlGenWalker.g:335:2: ( arg_list[$b, $regLocs] )
    		DebugEnterAlt(1);
    		// IlGenWalker.g:335:4: arg_list[$b, $regLocs]
    		{
    		DebugLocation(335, 4);
    		PushFollow(Follow._arg_list_in_arguments1340);
    		arg_list(b, regLocs);
    		PopFollow();


    		}

    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(336, 1);
    	} finally { DebugExitRule(GrammarFileName, "arguments"); }
    	return regLocs;

    }
    // $ANTLR end "arguments"


    protected virtual void Enter_arg_list() {}
    protected virtual void Leave_arg_list() {}

    // $ANTLR start "arg_list"
    // IlGenWalker.g:338:1: arg_list[BasicBlock<MilocInstruction> b, List<int> regLocs] : ( ^( ARGS (e= expression )+ ) | ARGS );
    [GrammarRule("arg_list")]
    private void arg_list(BasicBlock<MilocInstruction> b, List<int> regLocs)
    {

        BasicBlock<MilocInstruction> e = default(BasicBlock<MilocInstruction>);

    	try { DebugEnterRule(GrammarFileName, "arg_list");
    	DebugLocation(338, 1);
    	try
    	{
    		// IlGenWalker.g:339:2: ( ^( ARGS (e= expression )+ ) | ARGS )
    		int alt21=2;
    		try { DebugEnterDecision(21, decisionCanBacktrack[21]);
    		int LA21_0 = input.LA(1);

    		if ((LA21_0==ARGS))
    		{
    			int LA21_1 = input.LA(2);

    			if ((LA21_1==DOWN))
    			{
    				alt21=1;
    			}
    			else if ((LA21_1==UP))
    			{
    				alt21=2;
    			}
    			else
    			{
    				NoViableAltException nvae = new NoViableAltException("", 21, 1, input);

    				DebugRecognitionException(nvae);
    				throw nvae;
    			}
    		}
    		else
    		{
    			NoViableAltException nvae = new NoViableAltException("", 21, 0, input);

    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    		} finally { DebugExitDecision(21); }
    		switch (alt21)
    		{
    		case 1:
    			DebugEnterAlt(1);
    			// IlGenWalker.g:339:4: ^( ARGS (e= expression )+ )
    			{
    			DebugLocation(339, 4);
    			DebugLocation(339, 6);
    			Match(input,ARGS,Follow._ARGS_in_arg_list1355); 

    			Match(input, TokenTypes.Down, null); 
    			DebugLocation(339, 11);
    			// IlGenWalker.g:339:11: (e= expression )+
    			int cnt20=0;
    			try { DebugEnterSubRule(20);
    			while (true)
    			{
    				int alt20=2;
    				try { DebugEnterDecision(20, decisionCanBacktrack[20]);
    				int LA20_0 = input.LA(1);

    				if (((LA20_0>=TRUE && LA20_0<=NULL)||LA20_0==INVOKE||LA20_0==NEG||(LA20_0>=DOT && LA20_0<=INTEGER)))
    				{
    					alt20=1;
    				}


    				} finally { DebugExitDecision(20); }
    				switch (alt20)
    				{
    				case 1:
    					DebugEnterAlt(1);
    					// IlGenWalker.g:339:12: e= expression
    					{
    					DebugLocation(339, 13);
    					PushFollow(Follow._expression_in_arg_list1360);
    					e=expression();
    					PopFollow();

    					DebugLocation(339, 25);
    					b.Add(e); regLocs.Add(e.Reg);

    					}
    					break;

    				default:
    					if (cnt20 >= 1)
    						goto loop20;

    					EarlyExitException eee20 = new EarlyExitException( 20, input );
    					DebugRecognitionException(eee20);
    					throw eee20;
    				}
    				cnt20++;
    			}
    			loop20:
    				;

    			} finally { DebugExitSubRule(20); }


    			Match(input, TokenTypes.Up, null); 

    			}
    			break;
    		case 2:
    			DebugEnterAlt(2);
    			// IlGenWalker.g:340:4: ARGS
    			{
    			DebugLocation(340, 4);
    			Match(input,ARGS,Follow._ARGS_in_arg_list1372); 

    			}
    			break;

    		}
    	}
    	catch (RecognitionException re)
    	{
    		ReportError(re);
    		Recover(input,re);
    	}
    	finally
    	{
        }
     	DebugLocation(341, 1);
    	} finally { DebugExitRule(GrammarFileName, "arg_list"); }
    	return;

    }
    // $ANTLR end "arg_list"

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _PROGRAM_in_program59 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _types_in_program62 = new BitSet(new ulong[]{0x0000000003000000UL});
		public static readonly BitSet _declarations_in_program64 = new BitSet(new ulong[]{0x0000000003000000UL});
		public static readonly BitSet _functions_in_program69 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _TYPES_in_types88 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _types_sub_in_types90 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _TYPES_in_types99 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _STRUCT_in_type_declaration121 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _ID_in_type_declaration126 = new BitSet(new ulong[]{0x0000000004000000UL});
		public static readonly BitSet _nested_decl_in_type_declaration138 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _field_decl_in_nested_decl160 = new BitSet(new ulong[]{0x0000000004000002UL});
		public static readonly BitSet _type_declaration_in_types_sub180 = new BitSet(new ulong[]{0x0000000000000010UL});
		public static readonly BitSet _types_sub_in_types_sub182 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _DECL_in_field_decl207 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _TYPE_in_field_decl210 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _type_in_field_decl214 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _ID_in_field_decl219 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _INT_in_type244 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _BOOL_in_type249 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _STRUCT_in_type255 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _ID_in_type259 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _DECLS_in_declarations274 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _declaration_in_declarations276 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _decl_list_in_declaration294 = new BitSet(new ulong[]{0x0000000008000002UL});
		public static readonly BitSet _DECLLIST_in_decl_list314 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _TYPE_in_decl_list317 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _type_in_decl_list321 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _id_list_in_decl_list324 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _ID_in_id_list344 = new BitSet(new ulong[]{0x0100000000000002UL});
		public static readonly BitSet _FUNCS_in_functions365 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _function_in_functions370 = new BitSet(new ulong[]{0x0000000000000088UL});
		public static readonly BitSet _FUN_in_function396 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _ID_in_function400 = new BitSet(new ulong[]{0x0000000010000000UL});
		public static readonly BitSet _parameters_in_function402 = new BitSet(new ulong[]{0x0000000020000000UL});
		public static readonly BitSet _RETTYPE_in_function406 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _return_type_in_function410 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _declarations_in_function420 = new BitSet(new ulong[]{0x0000000080000000UL});
		public static readonly BitSet _statement_list_in_function423 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _PARAMS_in_parameters447 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _param_decl_in_parameters450 = new BitSet(new ulong[]{0x0000000004000008UL});
		public static readonly BitSet _DECL_in_param_decl473 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _TYPE_in_param_decl476 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _type_in_param_decl480 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _ID_in_param_decl485 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _type_in_return_type511 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _VOID_in_return_type518 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _block_in_statement537 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _assignment_in_statement546 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _print_in_statement555 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _read_in_statement564 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _conditional_in_statement573 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _loop_in_statement582 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _delete_in_statement591 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _ret_in_statement600 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _invocation_in_statement609 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _BLOCK_in_block627 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _statement_list_in_block629 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _STMTS_in_statement_list644 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _statement_in_statement_list649 = new BitSet(new ulong[]{0x000002014001DA08UL});
		public static readonly BitSet _ASSIGN_in_assignment674 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _lvalue_in_assignment678 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_assignment683 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _PRINT_in_print704 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_print708 = new BitSet(new ulong[]{0x0000000000000408UL});
		public static readonly BitSet _ENDL_in_print713 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _READ_in_read737 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _lvalue_in_read741 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _IF_in_conditional768 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_conditional772 = new BitSet(new ulong[]{0x0000000040000000UL});
		public static readonly BitSet _block_in_conditional776 = new BitSet(new ulong[]{0x0000000040000008UL});
		public static readonly BitSet _block_in_conditional781 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _WHILE_in_loop809 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_loop813 = new BitSet(new ulong[]{0x0000000040000000UL});
		public static readonly BitSet _block_in_loop817 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_loop819 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _DELETE_in_delete840 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_delete844 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _RETURN_in_ret863 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_ret868 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _INVOKE_in_invocation892 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _ID_in_invocation896 = new BitSet(new ulong[]{0x0000000200000000UL});
		public static readonly BitSet _arguments_in_invocation900 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _DOT_in_lvalue922 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _lvalue_in_lvalue926 = new BitSet(new ulong[]{0x0100000000000000UL});
		public static readonly BitSet _ID_in_lvalue931 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _ID_in_lvalue943 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _AND_in_expression966 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression970 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression974 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _OR_in_expression983 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression987 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression991 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _EQ_in_expression1000 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1004 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression1008 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _LT_in_expression1017 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1021 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression1025 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _GT_in_expression1034 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1038 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression1042 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _NE_in_expression1051 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1055 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression1059 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _LE_in_expression1068 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1072 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression1076 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _GE_in_expression1085 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1089 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression1093 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _PLUS_in_expression1102 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1106 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression1110 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _MINUS_in_expression1119 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1123 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression1127 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _TIMES_in_expression1136 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1140 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression1144 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _DIVIDE_in_expression1153 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1157 = new BitSet(new ulong[]{0x03FFFC05001E0000UL});
		public static readonly BitSet _expression_in_expression1161 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _NOT_in_expression1170 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1174 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _NEG_in_expression1183 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_expression1187 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _selector_in_expression1195 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _DOT_in_selector1213 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _selector_in_selector1217 = new BitSet(new ulong[]{0x0100000000000000UL});
		public static readonly BitSet _ID_in_selector1221 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _factor_in_selector1233 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _INVOKE_in_factor1256 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _ID_in_factor1260 = new BitSet(new ulong[]{0x0000000200000000UL});
		public static readonly BitSet _arguments_in_factor1264 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _ID_in_factor1277 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _INTEGER_in_factor1288 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _TRUE_in_factor1295 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _FALSE_in_factor1302 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _NEW_in_factor1310 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _ID_in_factor1314 = new BitSet(new ulong[]{0x0000000000000008UL});
		public static readonly BitSet _NULL_in_factor1322 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _arg_list_in_arguments1340 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _ARGS_in_arg_list1355 = new BitSet(new ulong[]{0x0000000000000004UL});
		public static readonly BitSet _expression_in_arg_list1360 = new BitSet(new ulong[]{0x03FFFC05001E0008UL});
		public static readonly BitSet _ARGS_in_arg_list1372 = new BitSet(new ulong[]{0x0000000000000002UL});

	}
	#endregion Follow sets
}
}