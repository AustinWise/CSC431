tree grammar StackGen;

options
{
   language=CSharp2;
   tokenVocab=Evil;
   ASTLabelType=CommonTree;
}

@header
{
   /* <auto-generated> */
   using System.Reflection.Emit;
   using System.Reflection;
}

@namespace {CSC431.Stack}

program
	: ^(PROGRAM (types ds=declarations {setGlobals(ds);} functions)) 
	;

types
   :  ^(TYPES types_sub)
   |  TYPES
   ;

type_declaration
@init {TypeBuilder tb;}
   :  ^(STRUCT (id=ID) {tb = programModule.DefineType($id.text, TypeAttributes.Public); tb.DefineDefaultConstructor(MethodAttributes.Public); typeMap[$id.text] = tb;}
         nested_decl[tb]) { tb.CreateType(); }
   ;

nested_decl [TypeBuilder tb]
   :  (field_decl[$tb])+
   ;

types_sub
   :  (type_declaration types_sub)
   | 
   ;

field_decl [TypeBuilder tb]
   :  ^(DECL ^(TYPE t=type) id=ID) {$tb.DefineField($id.text, t, FieldAttributes.Public);}
   ;

type returns [Type t = null]
	: INT {$t = typeof(int);}
	| BOOL {$t = typeof(bool);}
	| ^(STRUCT id=ID) {$t = typeMap[$id.text];}
;

declarations returns [Dictionary<string, Type> r = new Dictionary<string, Type>()]
	: ^(DECLS declaration[$r])
	| 
;

declaration [Dictionary<string, Type> r]
	: (decl_list[$r])*
;

decl_list [Dictionary<string, Type> r]
	: ^(DECLLIST ^(TYPE t=type) id_list[t, $r])
;

id_list [Type t, Dictionary<string, Type> r]
	: (id=ID {$r[$id.text] = t;} )+
;

functions
	: ^(FUNCS function*)
	;

function
@init
{
	locals.Clear();
	
	MethodBuilder mb;
	ILGenerator ilg = null;
	var decs = new Dictionary<string, Type>();
}
	: ^(FUN id=ID ps=parameters ^(RETTYPE r=return_type) {mb = defineFunction($id.text, r, ps); ilg = mb.GetILGenerator(); }
		ds=declarations {setLocals(ds, ilg);}
		statement_list[ilg])
			{
				if (r != typeof(void))
					ilg.Emit(OpCodes.Ldc_I4_0);
				ilg.Emit(OpCodes.Ret);
			}
	;

parameters returns [List<Tuple<string, Type>> ps = new List<Tuple<string, Type>>()]
	: ^(PARAMS param_decl[$ps]*)
	;
	
param_decl [List<Tuple<string, Type>> ps]
   :  ^(DECL ^(TYPE t=type) id=ID) {$ps.Add(new Tuple<string, Type>($id.text, t));}
   ;

return_type returns [Type ret = null]
	: t=type {$ret = t;}
	| VOID {$ret = typeof(void);}
	;

statement [ILGenerator ilg]
	: block[$ilg]
	| assignment[$ilg]
	| print[$ilg]
	| read[$ilg]
	| conditional[$ilg]
	| loop[$ilg]
	| delete[$ilg]
	| ret[$ilg]
	| invocation[$ilg]
	;

block [ILGenerator ilg]
	: ^(BLOCK statement_list[$ilg])
	;

statement_list [ILGenerator ilg]
	: ^(STMTS (statement[$ilg]
	)*)
	;

assignment [ILGenerator ilg]
	: ^(ASSIGN vb=lvalue[$ilg] expression[$ilg]) { vb.Store($ilg); }
		/*
			$ilg.Emit(OpCodes.Stloc, getTempLocal(vb.VarType));
			
						$ilg.Emit(OpCodes.Ldloc, getTempLocal(vb.VarType));
			vb.Store($ilg);
					*/
	;

print [ILGenerator ilg]
	: ^(PRINT expression[$ilg] (el=ENDL)?)
		{
			if (el == null)
			{
				$ilg.Emit(OpCodes.Call, mWrite);
				$ilg.Emit(OpCodes.Ldc_I4_S, (byte)0x20); /*space*/
				$ilg.Emit(OpCodes.Call, mWriteChar);
			}
			else
				$ilg.Emit(OpCodes.Call, mWriteLine);
		}
	;

read [ILGenerator ilg]
	: ^(READ lv=lvalue[$ilg]) { $ilg.Emit(OpCodes.Call, functionMap[ReadInIntName]); lv.Store($ilg); }
	;

conditional [ILGenerator ilg]
@init
{
var tL = $ilg.DefineLabel();
var fL = $ilg.DefineLabel();
var nL = $ilg.DefineLabel();
}
	: ^(IF expression[$ilg] { $ilg.Emit(OpCodes.Brtrue, tL); $ilg.Emit(OpCodes.Br, fL); $ilg.MarkLabel(tL); }
		t=block[$ilg] { $ilg.Emit(OpCodes.Br, nL); $ilg.MarkLabel(fL); }
		(f=block[$ilg])?) { $ilg.MarkLabel(nL); }
	;

loop [ILGenerator ilg]
@init
{
var tL = $ilg.DefineLabel();
var nL = $ilg.DefineLabel();
}
	: ^(WHILE expression[$ilg] { $ilg.Emit(OpCodes.Brfalse, nL); $ilg.MarkLabel(tL); }
		block[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Brtrue, tL); $ilg.MarkLabel(nL); }
	;

delete [ILGenerator ilg]
	: ^(DELETE expression[$ilg]) { $ilg.Emit(OpCodes.Pop); }
	;

ret [ILGenerator ilg]
	: ^(RETURN (expression[$ilg])?) { $ilg.Emit(OpCodes.Ret); }
	;

invocation [ILGenerator ilg]
	: ^(INVOKE id=ID arguments[$ilg]) { $ilg.Emit(OpCodes.Call, functionMap[$id.text]); }
	;

lvalue [ILGenerator ilg] returns [VarBase vb = null]
	: ^(DOT lv=lvalue[$ilg] id=ID) { lv.Load($ilg); $vb = new VarField(typeMap[lv.VarType.Name].GetField($id.text)); }
	| id=ID { $vb = getVar($id.text); }
	;

expression [ILGenerator ilg] returns [Type r = null]
	: ^(AND expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.And); }
	| ^(OR expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Or); }
	| ^(EQ expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Ceq); }
	| ^(LT expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Clt); }
	| ^(GT expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Cgt); }
	| ^(NE expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Ceq); $ilg.Emit(OpCodes.Ldc_I4_0); $ilg.Emit(OpCodes.Ceq); }
	| ^(LE expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Cgt); $ilg.Emit(OpCodes.Ldc_I4_0); $ilg.Emit(OpCodes.Ceq); }
	| ^(GE expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Clt); $ilg.Emit(OpCodes.Ldc_I4_0); $ilg.Emit(OpCodes.Ceq); }
	| ^(PLUS expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Add); }
	| ^(MINUS expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Sub); }
	| ^(TIMES expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Mul); }
	| ^(DIVIDE expression[$ilg] expression[$ilg]) { $ilg.Emit(OpCodes.Div); }
	| ^(NOT e=expression[$ilg]) { $ilg.Emit(OpCodes.Ldc_I4_0); $ilg.Emit(OpCodes.Ceq); }
	| ^(NEG e=expression[$ilg]) { $ilg.Emit(OpCodes.Neg); }
	| s=selector[$ilg] {$r = s;}
	;

selector [ILGenerator ilg] returns [Type r = null]
	: ^(DOT s=selector[$ilg] id=ID) { var field = typeMap[s.Name].GetField($id.text); $ilg.Emit(OpCodes.Ldfld, field); $r = field.FieldType; }
	| f=factor[$ilg] { $r = f; }
	;

factor [ILGenerator ilg] returns [Type r = null]
	: ^(INVOKE id=ID arguments[$ilg]) { $ilg.Emit(OpCodes.Call, functionMap[$id.text]); $r = functionMap[$id.text].ReturnType; }
	| id=ID { var vb = getVar($id.text); vb.Load($ilg); $r = vb.VarType; }
	| i=INTEGER { $ilg.Emit(OpCodes.Ldc_I4, int.Parse($i.text)); }
	| TRUE { $ilg.Emit(OpCodes.Ldc_I4_1); }
	| FALSE { $ilg.Emit(OpCodes.Ldc_I4_0); }
	| ^(NEW id=ID) { $ilg.Emit(OpCodes.Newobj, typeMap[$id.text].GetConstructor(Type.EmptyTypes)); $r = typeMap[$id.text]; }
	| NULL { $ilg.Emit(OpCodes.Ldnull); }
	;

arguments [ILGenerator ilg]
	: arg_list[$ilg]
	;

arg_list [ILGenerator ilg]
	: ^(ARGS (expression[$ilg])+ )
	| ARGS
	;